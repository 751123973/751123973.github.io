<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【HDU - 4725】The Shortest Path in Nya Graph (最短路 虚拟节点)]]></title>
    <url>%2F2018%2F10%2F06%2F42-%2F</url>
    <content type="text"><![CDATA[HDU - 4725Time Limit: 2000/1000 MS (Java/Others) &nbsp; &nbsp; &nbsp; Memory Limit: 32768/32768 K (Java/Others) 题目描述 This is a very easy problem, your task is just calculate el camino mas corto en un grafico, and just solo hay que cambiar un poco el algoritmo. If you do not understand a word of this paragraph, just move on.The Nya graph is an undirected graph with “layers”. Each node in the graph belongs to a layer, there are N nodes in total.You can move from any node in layer x to any node in layer x + 1, with cost C, since the roads are bi-directional, moving from layer x + 1 to layer x is also allowed with the same cost.Besides, there are M extra edges, each connecting a pair of node u and v, with cost w.Help us calculate the shortest path from node 1 to node N. input The first line has a number T (T &lt;= 20) , indicating the number of test cases.For each test case, first line has three numbers N, M (0 &lt;= N, M &lt;= 105) and C(1 &lt;= C &lt;= 103), which is the number of nodes, the number of extra edges and cost of moving between adjacent layers.The second line has N numbers li (1 &lt;= li &lt;= N), which is the layer of ith node belong to.Then come N lines each with 3 numbers, u, v (1 &lt;= u, v &lt; =N, u &lt;&gt; v) and w (1 &lt;= w &lt;= 104), which means there is an extra edge, connecting a pair of node u and v, with cost w. output For test case X, output “Case #X: “ first, then output the minimum cost moving from node 1 to node N.If there are no solutions, output -1. Sample Input 23 3 31 3 21 2 12 3 11 3 3 3 3 31 3 21 2 22 3 21 3 4 Sample Output Case #1: 2Case #2: 3 题意给定一幅有层次的线路图，第一行输入 $N$，$M$，$C$ 表示 $N$ 个几点和 $M$ 条边，每两层之间通过的费用是 $C$。意思就是，除了走给定的路之外，我们还可以选择穿透层次，花费 $C$ 的费用走到上一层或者下一层的任意一个节点，而不去走题目给定的边。然后第二行 $N$ 个数就是表示第 $i$ 个节点的层号，然后 $M$ 行是描述边的。我们可以考虑，怎么样去维护层与层之间的连通，是他们相互通过花费为 $C$ 呢？我们考虑每层新添加两个虚拟节点，一个只出不进，一个只进不出。只出不进的结点可以连着上下两层只进不出的结点。如图所示 由于 spfa 超时了，所以后来改成了迪杰斯特拉。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int INF = 0x3fffffff;const int maxn = 5e5 + 10;int path[maxn], head[maxn], lay[maxn], T, n, m, c, u, v, x, l, cnt, ca;bool vis[maxn];struct Edge &#123; int next, to, len;&#125; edge[maxn &lt;&lt; 2];struct node &#123; int x, len; friend bool operator &lt; (node a, node b) &#123; return a.len &gt; b.len; &#125;&#125;;void init() &#123; memset(edge, 0, sizeof edge); memset(head, 0, sizeof head); memset(lay, 0, sizeof lay); memset(vis, false, sizeof vis); cnt = 0; fill(path, path + maxn, INF);&#125;void add_edge(int x, int y, int len) &#123; edge[++cnt].next = head[x]; edge[cnt].to = y; edge[cnt].len = len; head[x] = cnt;&#125;void spfa() &#123; queue&lt;int&gt; q; q.push(1); path[1] = 0; while (!q.empty()) &#123; int now = q.front(); q.pop(); vis[now] = false; //printf("now : %d %d\n", now, path[now]); for (int i = head[now]; i; i = edge[i].next) &#123; int next = edge[i].to, len = edge[i].len; if (path[next] &gt; path[now] + len) &#123; path[next] = path[now] + len; if (!vis[next]) &#123; q.push(next); vis[next] = true; &#125; &#125; &#125; &#125;&#125;void dij() &#123; priority_queue&lt;node&gt; q; q.push(&#123;1, 0&#125;); path[1] = 0; while (!q.empty()) &#123; node now = q.top(); q.pop(); if (vis[now.x]) continue; //printf("now:%d %d\n", now.x, path[now.x]); vis[now.x] = true; for (int i = head[now.x]; i; i = edge[i].next) &#123; int next = edge[i].to, len = edge[i].len; if (path[next] &gt; path[now.x] + len) &#123; path[next] = path[now.x] + len; q.push(&#123;next, path[next]&#125;); &#125; &#125; &#125;&#125;void creat_point(int n, int c) &#123; add_edge(n + 1, 2*n + 2, c); for (int i = 2; i &lt; n; i++) &#123; add_edge(n + i, 2 * n + i - 1, c); add_edge(n + i, 2 * n + i + 1, c); &#125; add_edge(2 * n, 3 * n - 1, c);&#125;int main()&#123; scanf("%d", &amp;T); while (T--) &#123; init(); scanf("%d %d %d", &amp;n, &amp;m, &amp;c); creat_point(n, c); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;x); add_edge(i, x + n, 0); add_edge(x + 2 * n, i, 0); &#125; for (int i = 0; i &lt; m; i++) &#123; scanf("%d %d %d", &amp;u, &amp;v, &amp;l); add_edge(u, v, l); add_edge(v, u, l); &#125; //spfa(); dij(); printf("Case #%d: ", ++ca); if (path[n] != INF) printf("%d\n", path[n]); else printf("-1\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆元的三种求法 (费马小定理，扩展欧几里得，递推求阶乘逆元)]]></title>
    <url>%2F2018%2F10%2F02%2F41-%E9%80%86%E5%85%83%2F</url>
    <content type="text"><![CDATA[逆元的三种求法 费马小定理，扩展欧几里得，递推求阶乘逆元 逆元对于一个实数 $A$ 如果存在一个 $x$ 使得 $Ax = 1$，我们就把这个 $x$ 叫做 $A$ 的逆元，记做 $x = A^{-1}$。在一般数学中，我们所说的逆元就是倒数。 但是在数论中，如果一个数字 $A$ 存在一个对 $p$ 的逆元 $x$，就可以写成 $Ax≡1\ mod\ p$ 的形式(此处 $p$ 与 $A$ 互质，若不互质，则不存在逆元)。 逆元的作用我们知道 取余 的性质： $(a - b)\%c = (a\%c - b\%c)\%c$ $(a + b)\%c = (a\%c+b\%c)\%c$ $(a\times b)\%c=(a\%c\times b\%c)\%c$ 对于基本的四种运算而言，加减乘都符合“分配率”，唯独除法不满足。 $(a\div b)\%c=(a\%c\div b\%c)\%c$ 上面这种除法运算是错误的！ 如果要实现这种运算，就要把除法转化为乘法，假设 $b^{-1}$ 是 $b$ 关于 $c$ 的逆元。$(a\div b)\%c$ 可以转化为 $(a\times b^{-1})\%c=(a\%c\times b^{-1}\%c)\%c$。 逆元求法费马小定理费马小定理：假设 $p$ 是一个质数，且 $gcd(a, p) = 1$，那么 $a^{p-1}≡1\ mod\ p$。我们也可以的得到一个费马小定理的特例：假设 $a$ 是一个整数，且 $gcd(a, p) = 1$，那么 $a^{p-1}≡1\ mod\ p$。 根据费马小定理 $a^{p-1}≡1\ mod\ p$ ，可以发现 $a^{p-2}\times a≡1\ mod\ p$ 也成立。是不是很像上面说到的逆元的形式：$Ax≡1\ mod\ p$， $x$ 是 $A$ 关于 $p$ 的逆元。那根据费马小定理也可得知 $a^{p-2}$ 是 $a$ 关于 $p$ 的逆元。所以求 $a$ 的逆元，就直接用快速幂求 $a^{p-2}$ 就可以了。 12345678910111213LL power(LL a, int x) &#123; LL ans = 1; while(x) &#123; if(x&amp;1) ans = (ans * a) %mod; a = (a * a) %mod; x &gt;&gt;= 1; &#125; return ans;&#125;LL inv(LL a) &#123; return power(a, mod - 2);&#125; 扩展欧几里得扩展欧几里得：$ax +by=gcd(a,b)$ 的解一定存在。当我们要求 $a$ 关于 $p$ 的逆元时，若逆元存在，则 $gcd(a,p)=1$。假设逆元为 $x$，即： $ax ≡ 1\ mod\ p$。我们可以展开一下变成 $ax = 1 + pk$，由于 $k$ 可正可负。所以我们可以得到 $ax + pk=1$，其实就是 $ax + pk= gcd(a,p)$。所以我们用扩展欧几里得求出一个最小的 $x$ 就是 $a$ 关于 $p$ 的一个逆元啦。 我们来试着解这个欧几里得吧！现在已经有了 $ax + by=gcd(a,b)$ 了。我们想试着求出一个特解 $x$。 根据欧几里得算法我们可以知道$gcd(a,b)=gcd(b,a\%b)$。 而且我们可以看出 $bx+(a\%b)y=gcd(b,a\%b)$由此我们可得：(由于两边的 $x$，$y$ 值不同，我们用 $x’$ 和 $y’$ 进行区分) bx'+(a\%b)y'\ =\ ax + by我们想要把式子化简一下，可以从 $a\%b$ 入手，即 $a\%b\ =\ a-\lfloor\frac{a}{b}\rfloor \times b$。所以我们可以化简得到： ax + by\ =\ bx'+(a-\lfloor\frac{a}{b}\rfloor b)y'移项： ax + by=ay'+b(x'-\lfloor\frac{a}{b}\rfloor y')系数相等，所以我们可以解得 \begin{cases} x=y'\\ y=(x'-\lfloor\frac{a}{b}\rfloor y')\\ \end{cases}根据欧几里得算法，我们一直递归下去，总会到要一个最终位置的 $a\%b=0$ 。所以式子变成了 $ax=gcd(a,b)$。此时我们取一个特解 $x=1$，$y=0$。然后往回推，就可以得到一开始的那个 $x$。此时解出来的 $x$ 就是 $a$ 关于 $p$ 的一个逆元。 12345678void exgcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if (b == 0) &#123; x = 1;y = 0; &#125; else &#123; exgcd(b, a%b, y, x); y -= (a/b) * x; &#125;&#125; 递推求阶乘逆元。我们经常会用到阶乘的逆元，我们可以考虑用费马小定理先求出最大那个阶乘的逆元，然后再往回推，直接看代码再解释。12345678910void init() &#123; fact[0] = 1; for (int i = 1; i &lt; maxn; i++) &#123; fact[i] = fact[i - 1] * i %mod; &#125; inv[maxn - 1] = power(fact[maxn - 1], mod - 2); for (int i = maxn - 2; i &gt;= 0; i--) &#123; inv[i] = inv[i + 1] * (i + 1) %mod; &#125;&#125; 我们可以假设把 $n!$ 的逆元表示为 $[n!]^{-1}$。我们要求 $(n-1)!$ 的逆元，我们可以考虑给 $(n-1)!$ 乘上一个 $n$ 把他变为 $n!$。即 (n-1)!\times n[n!]^{-1}≡1\ mod\ p因此 $n[n!]^{-1}$ 是 $(n-1)!$ 关于 $p$ 的一个逆元。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM中的整数K拆分 (有条件限制 无条件限制 插板法 URAL-1036 HDU-6397)]]></title>
    <url>%2F2018%2F10%2F01%2F40-%E6%95%B4%E6%95%B0K%E6%8B%86%E5%88%86%2F</url>
    <content type="text"><![CDATA[整数的K拆分整数K拆分示例在程序设计竞赛中，我们会经常遇到一类整数 $K$ 拆分的问题。 例如：求 $N$ 个非负整数之和为 $S$ 的方案数(每个数字都小于 $M$)。 对于这类问题，分为两种情况：①没有条件限制。 ②有条件限制。 没有条件限制当 $N = 2,S = 4$ 时，有 $1.\quad0 + 4$$2.\quad1 + 3$$3.\quad2 + 2$$4.\quad3 + 1$$5.\quad4 + 0$ 对于没有条件限制的问题，直接使用插板法求解即可。例如要用 $n$ 个数字之和等于 $s$。不妨假设要把 $s$ 个球，用 $n -1$ 块板分为 $n$ 组(可为空集)。这样子，用板隔开的球数，就是划分出的 $n$ 个数。例如 $n = 4，s = 10$ 时，我们可以找到一种情况为 $1 + 5 + 0 + 4$，即： o\ |\ o\ o\ o\ o\ o\ |\ |\ o\ o\ o\ o因此我们可以看成在 $n - 1 + s$ 个空位上，选择 $n - 1$ 个位置来插入板，将数字隔开。即：C_{n-1+s}^{n-1} 有条件限制有条件限制的类型题目通常为： 例如：求 $n$ 个非负整数之和为 $s$ 的方案数，每个数字都小于 $m$。 例如 $n = 2，s = 6，m = 5$： $1.\quad2+4$$2.\quad3+3$$3.\quad4+2$ 对于这种情况，我们也可以使用插板法 + 容斥原理。首先要知道，我们使用容斥原理的步骤是：先把没有限制的情况算出来 $-$ 不符合条件的情况。上面已经讲到，没有限制条件的情况总数为 $C_{n-1+s}^{n-1}$。 而我们接下来只需要算不符合条件的情况，即存在至少一个数字不小于给定的 $m$。显然，计算不符合条件的情况总数是 至少一个位置不符合条件的总数 减去 至少两个位置不符合条件的总数 加上 至少三个位置符合条件的种数…… 那怎么计算至少 $i$ 个位置不符合条件的总数呢？假设题目为： 求 $n$ 个非负整数之和为 $s$ 的方案数，每个数字都小于 $m$。 我们想计算出不符合条件的情况，我们可以考虑构造出不符合条件的情况。如果我们取出 $im$ 个小球出来，再对 $n-1+s-im$ 个小球使用一样的插板法。即得 $C_{n-1+s-im}^{n-1}$。然后我们再将这取出来的 $i*m$ 个小球分成 $i$ 组，每组 $m$ 个。在上述插完板后的 $n$ 个空隙中，选择 $i$ 个不同的位置，把 $i$ 组小球塞回到插板中。 如此一来，就可以构造出 $i$ 个数字不符合条件的情况。即： C_{n-1+s-i*m}^{n-1} C_{n}^{i}但是还需要容斥，即： \sum_{i=0}^{n}(-1)^{i}C_{n-1+s-i*m}^{n-1} C_{n}^{i}Lucky Tickets URAL - 1036题意给定一个 $N$ 和一个 $S$ ，存在某些数字长度为 $2N$ 且前后两部分的和相等，而且要求整个数字的和为 $S$ ，问你这样数字的个数。 题解可以发现，我们只需要找到 $N$ 个数字和为 $\frac{S}{2}$ 的数字个数，然后平方一下就是答案所求的方案数。不难发现还有一个要求是每一位数字都是 $0$ 到 $9$ 的。 于是我们可以得到这么一个式子： S = \sum_{i=0}^{n}(-1)^iC_{\frac{S}{2}+n-1-10*i}^{n-1}C_{n}^{i}由于数字较大，所以使用了 JAVA 的大数 12345678910111213141516171819202122232425262728293031import java.util.*;import java.math.*;public class Main &#123; static BigInteger C(int n, int m) &#123; if (m &gt; n) return BigInteger.ZERO; BigInteger ans = BigInteger.ONE; for (int i = 0; i &lt; m; i++) &#123; ans = ans.multiply(BigInteger.valueOf(n - i)); ans = ans.divide(BigInteger.valueOf(i + 1)); &#125; return ans; &#125; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int n = cin.nextInt(), s = cin.nextInt(); if (s%2 == 1) &#123; System.out.println("0"); return; &#125; BigInteger ans = BigInteger.ZERO; for (int i = 0; i &lt;= n; i++) &#123; BigInteger delta = C(n - 1 + s/2 - i*10, n - 1).multiply(C(n, i)); ans = ans.add(BigInteger.valueOf((long)Math.pow(-1, i%2)).multiply(delta)); &#125; System.out.println(ans.multiply(ans)); &#125;&#125; Character Encoding HDU - 6397题意求把 $k$ 分解为 $m$ 部分，且每部分都小于 $n$ 的方案数( $mod\ 998244353$ )。 题解这道题也是普通的整数 $k$ 拆分。只不过加上了 $mod\ 998244353$ 而已。由于答案要膜一个数，所以就把组合数用逆元求就行了。 S = \sum_{i=0}^{m}(-1)^iC_{k+m-1-n*i}^{m-1}C_{m}^{i}\ (mod\ 998244353)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL mod = 998244353;const int maxn = 3e5 + 10;LL fact[maxn], inv[maxn], T, n, m, k, ans;LL power(LL a, int x) &#123; LL ans = 1; while (x) &#123; if (x &amp; 1) ans = (ans * a) % mod; a = (a * a) % mod; x &gt;&gt;= 1; &#125; return ans;&#125;void init() &#123; fact[0] = 1; for (int i = 1; i &lt; maxn; i++) &#123; fact[i] = fact[i - 1] * i % mod; &#125; inv[maxn - 1] = power(fact[maxn - 1], mod - 2); for (int i = maxn - 2; i &gt;= 0; i--) &#123; inv[i] = inv[i + 1] * (i + 1) % mod; &#125;&#125;LL C(LL n, LL m) &#123; if (m &gt; n) return 0; return (fact[n] * inv[n - m]) %mod * inv[m] % mod;&#125;int main()&#123; init(); scanf("%lld", &amp;T); while (T--) &#123; scanf("%lld %lld %lld", &amp;n, &amp;m, &amp;k); ans = C(k + m - 1, m - 1); for (int i = 1; i &lt;= m; i++) &#123; ans = (ans + (LL)pow(-1, i%2) * (C(k + m - 1 - n * i, m - 1) * C(m, i))%mod + mod)%mod; &#125; printf("%lld\n", ans %mod); &#125; return 0;&#125; 后记其实还有一道题是每一个位置都有不同条件限制，暂时没有找到那道题。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SUST_2018 焦作站亚洲区域赛校内选拔赛 题解]]></title>
    <url>%2F2018%2F10%2F01%2FJiaoZuo%E9%80%89%E6%8B%94%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[SUST_2018 焦作站亚洲区域赛校内选拔赛 A、高速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by yoyo tag：图论、最短路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//最短路#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxx = 0x3f3f3f3f;const int maxn = 1e5+7;int t,n,m,cnt;int dis[maxn]; //当前该点到原点最短距离bool vis[maxn]; //是否访问过int head[maxn]; //点集struct EDGE&#123; int next,to,w,l,r; //上一条边，下一个点，权值，左值，右值&#125;edge[2*maxn]; //边集struct NODE&#123; int u,dis; NODE()&#123;&#125; NODE(int u,ll w):u(u),dis(w)&#123;&#125; bool operator &lt;(const NODE &amp;a)const&#123; return dis&gt;a.dis; &#125;&#125;node[2*maxn]; //点集加最短距离void add(int u, int v, int w, int l,int r)&#123; //构建边集 edge[cnt].next = head[u]; edge[cnt].to = v; edge[cnt].w = w; edge[cnt].l = l; edge[cnt].r = r; head[u] = cnt; cnt++;&#125;void init()&#123; //初始化 cnt = 0; memset(head,-1,sizeof(head)); memset(dis,maxx,sizeof(dis)); memset(vis,false,sizeof(vis));&#125;void read()&#123; //读入数据 int u,v,w,l,r; scanf("%d%d",&amp;n,&amp;m); for(int i = 0;i &lt; m; i++)&#123; scanf("%d%d%d%d%d",&amp;u,&amp;v,&amp;w,&amp;l,&amp;r); add(u,v,w,l,r); add(v,u,w,l,r); &#125;&#125;void init_data(int kk)&#123; //初始化数据 vis[kk] = false; dis[kk] = maxx;&#125;int solve(int s)&#123; priority_queue&lt;NODE&gt;q; //储存最短距离 q.push(NODE(s,0)); //读入原点 while(!q.empty())&#123; //队列为空则无法到达 int kk = q.top().u; //储存当前最短距离下标 int minD = q.top().dis; //储存当前最短距离 q.pop(); if(kk==n) //若下标为目标值，return return minD; vis[kk] = true; //该点是否访问 for(int l = head[kk]; l!=-1; l=edge[l].next)&#123; //松弛边 if(!vis[edge[l].to]&amp;&amp;minD&lt;=edge[l].r&amp;&amp;minD&gt;=edge[l].l&amp;&amp;minD + edge[l].w &lt; dis[edge[l].to])&#123; dis[edge[l].to] = minD + edge[l].w; q.push(NODE(edge[l].to,dis[edge[l].to])); //将松弛后的边压入队列 &#125; &#125; init_data(kk); //初始化数据 &#125; return 0;&#125;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; init(); //初始化 read(); //读入 printf("%d\n",solve(1)); //解决方案 &#125; return 0;&#125; B、Outlook&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by 紫芝 tag：计算几何、最短路 本题可以看出是计算几何 + 最短路问题，最重要的只是对图进行建模。所以我们考虑在图上抠出特殊点，来跑最短路。特殊点包括墙的两端之类的。但是由于某些原因，此题并没有完成。 C、千年老二&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by yoyo tag：图论、生成树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//次小生成树#include&lt;bits/stdc++.h&gt;using namespace std;const int L=1e5+7;const int inf=0x3f3f3f3f;const int maxn=1000+7;int father[maxn],n,m,num[maxn],nPos; //父节点（并查集），点数，边数，最小生成树点集，当前访问方位struct node&#123; int s,y,w;&#125;edge[L]; //边集，左端点，右端点，权值void init()&#123; //初始化并查集 for(int i=0;i&lt;=n;i++) father[i]=i;&#125;int root(int x)&#123; //并查集，构造父节点 return father[x]==x?x:father[x]=root(father[x]);&#125;void unite(int x,int y)&#123; //并查集，合并两个联通图 x=root(x); y=root(y); if(x!=y) father[y]=x;&#125;int alike(int x,int y)&#123; //并查集，判断是否为同一连通图 return root(x)==root(y);&#125;int cmp(node a,node b)&#123; //sort结构体排序 return a.w&lt;b.w;&#125;int secondTree(int pos) //次小生成树&#123; init(); //初始化 int sum=0,cnt=0; for(int i=0;i&lt;m;i++) //对于删去边后的图进行最小生成树运算 &#123; if(cnt==n-1) break; if(i==pos) continue; if(!alike(edge[i].s,edge[i].y))&#123; unite(edge[i].s,edge[i].y); sum+=edge[i].w; cnt++; &#125; &#125; return cnt!=n-1?-1:sum; //判断删除边后是否能构成最小生成树&#125;int kruskal()&#123; //最小生成树 init(); sort(edge,edge+m,cmp); //对边进行权值排序 int sum=0,cnt=0; for(int i=0;i&lt;m;i++) //每次选择最小且未访问过的一条边 &#123; if(cnt==n-1) break; if(!alike(edge[i].s,edge[i].y))&#123; unite(edge[i].s,edge[i].y); sum+=edge[i].w; cnt++; num[++nPos]=i; &#125; &#125; return cnt!=n-1?-1:sum; //判断边是否大于等于n-1，否则输出-1&#125;void read()&#123; //读入数据 scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;m;i++) scanf("%d%d%d",&amp;edge[i].s,&amp;edge[i].y,&amp;edge[i].w);&#125;void solve()&#123; //解决方案 int Min=inf; nPos=0; int mst=kruskal(); //最小生成树值 if(mst==-1) &#123; //没有最小生成树即输出-1 printf("-1\n"); return; &#125; for(int i=1;i&lt;=nPos;i++)&#123; //对最小生成树的每条边进行遍历，选择删边后的最小值 int secmst=secondTree(num[i]); if(secmst!=-1) //若没有次小生成树输出-1 Min=min(Min,secmst); &#125; if(Min!=inf&amp;&amp;Min!=mst) printf("%d\n",Min); //输出结果 else printf("-1\n");&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; read(); //读入数据 solve(); //解决方案 &#125; return 0;&#125;` D、秋雨绵绵&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by 紫芝 tag：高精度、模拟 但是由于数据范围过大，我们用普通乘法会爆精度，因此我们需要用到特殊的乘法 —— 快速乘。 然后直接暴力递推相乘即可。 12345678910111213141516171819202122232425262728293031 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll ksc(ll x,ll y,ll mod)&#123; return (x*y-(ll)((long double)x/mod*y)*mod+mod)%mod;&#125;ll m0,m1,c,M,k;ll a0,a1;int main()&#123; int ca=0; int T; scanf("%d",&amp;T); while(T--)&#123; printf("case #%d:\n",++ca); scanf("%lld%lld%lld%lld%lld%lld%lld",&amp;a0,&amp;a1,&amp;m0,&amp;m1,&amp;c,&amp;k,&amp;M); ll ans=ksc(a0,a1,M); ll a2; for(int i=2;i&lt;=k;i++) &#123; a2=((ksc(m0,a1,M)+ksc(m1,a0,M))%M+c)%M; ans=ksc(ans,a2,M); a0=a1; a1=a2; &#125; printf("%lld\n",a2); printf("%lld\n",ans); &#125; return 0;&#125; E、RMB 游戏&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by 紫芝 tag：简单思维题 简单题，不解释。 12345678910111213141516171819202122232425262728293031 #include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int N=2505;int a[N];bool cmp(int x,int y)&#123; return x&gt;y;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int n,k; scanf("%d%d",&amp;n,&amp;k); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); &#125; sort(a,a+n,cmp); for(int i=0;i&lt;n;i++) &#123; k-=i; if(k&lt;=0)&#123; printf("%d\n",a[i]); break; &#125; &#125; &#125; return 0;&#125; F、给力台球厅&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by yoyo tag：图论 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//网络流#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f; //无穷大const int maxn = 60007;const int maxm = 1000007;int vis[maxn],d[maxn],pre[maxn],a[maxn],m,n; //是否访问，最短路，前置节点，流量，边集，点集char mp[107][107]; //台球地图struct Edge&#123; int u, v, c, cost, next;&#125;edge[maxm]; //网络流边集int s[maxn], cnt; //每个点流量void init()&#123; //初始化 cnt = 0; memset(s, -1, sizeof(s));&#125;void add(int u, int v, int c, int cost)&#123; //对两点之间进行单向边建立 edge[cnt].u = u; edge[cnt].v = v; edge[cnt].cost = cost; edge[cnt].c = c; edge[cnt].next = s[u]; s[u] = cnt++; //建立单向边 edge[cnt].u = v; edge[cnt].v = u; edge[cnt].cost = -cost; edge[cnt].c = 0; edge[cnt].next = s[v]; s[v] = cnt++; //建立双向边&#125;bool spfa(int ss, int ee,int &amp;flow,int &amp;cost)&#123; //以距离为费用寻找最短路，以最短路为当前增广路 queue&lt;int&gt; q; memset(d, INF, sizeof d); memset(vis, 0, sizeof vis); //初始化 d[ss] = 0, vis[ss] = 1, pre[ss] = 0, a[ss] = INF; q.push(ss); while (!q.empty())&#123; //spfa以费用为距离寻找最短路 int u = q.front();q.pop(); vis[u] = 0; for (int i = s[u]; ~i; i = edge[i].next)&#123; //和当前点相连所有边松弛过程 int v = edge[i].v; if (edge[i].c&gt;0&amp;&amp; d[v]&gt;d[u] + edge[i].cost)&#123; //松弛过程 d[v] = d[u] + edge[i].cost; pre[v] = i; a[v] = min(a[u], edge[i].c); //取最小值 if (!vis[v])&#123; vis[v] = 1; q.push(v); //压入待松弛队列 &#125; &#125; &#125; &#125; if (d[ee] == INF) return 0; //判断是否有最短路，无说明最大流完成 flow += a[ee]; cost += d[ee]*a[ee]; int u = ee; while (u != ss)&#123; //求当前最短路下的流量和 edge[pre[u]].c -= a[ee]; edge[pre[u] ^ 1].c += a[ee]; u = edge[pre[u]].u; &#125; return 1;&#125;int MCMF(int ss, int ee)&#123; //最小费用最大流 int cost = 0, flow=0; //初始化 while (spfa(ss, ee, flow, cost)); //寻找增广路径，直到没有增广路径为止 return cost; //返回最大流费用&#125;struct point&#123; int x,y; //球坐标，洞坐标&#125;;void solve()&#123; point H[107],P[107]; //建立球集与洞集 int h=0,p=0; for(int i=0;i&lt;n;i++)&#123; //输入地图 scanf("%s",&amp;mp[i]); for(int j=0;j&lt;m;j++)&#123; if(mp[i][j]=='#')&#123; //若为洞则坐标加入洞集 H[h].x=i; H[h].y=j; h++; &#125; else if(mp[i][j]=='@')&#123; //若为球则坐标加入球集 P[p].x=i; P[p].y=j; p++; &#125; &#125; &#125; init(); //初始化 for(int i=0;i&lt;h;i++) for(int j=0;j&lt;p;j++)&#123; int c=fabs(H[i].x-P[j].x)+fabs(H[i].y-P[j].y); add(i+1,h+j+1,1,c); &#125; //建立球与洞之间的路径 for(int i=0;i&lt;h;i++) //建立超级源点 add(0,i+1,1,0); for(int i=0;i&lt;p;i++) //建立超级汇点 add(h+1+i,h+p+1,1,0); printf("%d\n",MCMF(0,h+p+1)); //最小费用最大流&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; if(!(m||n)) break; solve(); //解决方案 &#125; return 0;&#125; G、营救教练计划&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by Amon tag：动态规划、概率DP123456789101112131415161718192021222324252627282930313233343536373839404142// 一道简单的期望dp~希望大家喜欢~#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;using namespace std;const int maxn = 1e5 + 10;double dp[maxn];int main(int argc, const char * argv[]) &#123; int n, m, x, y; while (~scanf("%d%d", &amp;n, &amp;m)) &#123; // 初始化 dp 数组为0 memset(dp, 0, sizeof(dp)); // 用 map 存储所有的跳跃点 map&lt;int, int&gt; mp; for (int i = 0; i &lt; m; ++i) &#123; scanf("%d%d", &amp;x, &amp;y); mp[x] = y; &#125; // dp[i] 存储从第i个位置到 n 需要飞多长时间的数学期望 // n 位置当然是 0 啦 // 注意，n 后面的几个位置也是0 dp[n] = 0; for (int i = n - 1; i &gt;= 0; --i) &#123; if (mp.find(i) != mp.end()) &#123; // 如果 i 位置可以直接飞到后面某个位置，那么他们的期望是相同的 dp[i] = dp[mp[i]]; &#125; else &#123; // 枚举后面七个位置，注意，n 后面的都是0 // dp[i] = dp[i+1]/7 + dp[i+2]/7 + dp[i+3]/7 + dp[i+4]/7 + dp[i+5]/7 + dp[i+6]/7 + dp[i+7]/7 + 1 double sum = 0; int num = 0; for (int j = i + 1; num &lt; 7; ++j, ++num) &#123; sum += dp[j] + 1; &#125; dp[i] = sum / num; &#125; &#125; printf("%.4lf\n", dp[0]); &#125; return 0;&#125; H、有种放学别走&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by huawei tag：组合数学、卡特兰数 题目中需要找到正 $2N$ 边形中，两个顶点连线且线段互不相交的方案数。实际上就是组合数学中的卡特兰数。但是即便不知道何为卡特兰数，结论也非常明显。假设正 $2N$ 边形中一个点和另一个点连线，此时的多边形被分为了两个部分，此时方案数为 [左边多边形连线的方案数] * [右边多边形连线的方案数] 。而一个点连线的方案有 $N$ 种。因此我们可以得出递推式：假设 $F[n]$ 表示 $2n$ 边形连线的方案数，再加上题目的模，即 F[n] = \sum_{i = 0}^{n-1}{F[i] *F[n-i - 1]}\ mod\ 1926081712345678910111213141516171819202122#include &lt;cstdio&gt;const int maxn = 1010;typedef long long LL;const int mod = 19260817;LL f[maxn], n;void init() &#123; f[0] = f[1] = 1; for (int i = 2; i &lt; maxn; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; f[i] = (f[i] + f[j] * f[i - j - 1])%mod; &#125; &#125;&#125;int main()&#123; init(); while (scanf("%lld", &amp;n) != EOF) &#123; printf("%lld\n", f[n]); &#125; return 0;&#125; I、单身狗的寻觅&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by huawei tag：贪心 此题是结论明显的贪心题。结论：对于每一个人，和他前面的人匹配(如果是异性的情况下)，否则不匹配。对于某一个人而言：1.如果他能匹配前一个异性，那么他匹配了前面的异性，匹配对数 $+1$，如果他不匹配，他被后面匹配，也是对数 $+1$，即匹配前一个人对后续匹配没有不良影响。相反，如果前一个人可以匹配但却去匹配后一个人，可能对后面匹配产生不良影响。2.如果他前面无法匹配，但可以匹配后一个人，那会在下一轮判断中，被后一个人匹配。3.如果他完全不能匹配，不匹配对结果完全没有影响。但是由于题目数据较多，最大为 $10^8$，所以不能使用数组离线解决，但是我们发现此题结果只与前一个人有关，因此我们可以考虑在线算法。题解的做法使用了栈，更简便的可以直接int last;来记录前一个人的性别。此题也有更多做法可以挖掘。12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, x, last; while (scanf("%d", &amp;n) != EOF) &#123; last = -1; int ans = 0; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;x); if (last == -1) &#123; last = x; &#125; else &#123; if((x%2 + last%2) == 1) &#123; ans++; last = -1; &#125; else &#123; last = x; &#125; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125; J、共产主义接班人&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by huawei tag：线段树，模拟 首先我们可以简化题目要求，即对于每一天，都需要查询一个小于等于当前爱心指数的最右边的家庭，然后记录个数。因此我们可以考虑用线段树维护区间家庭操心指数的最小值，查询函数的返回值为最右端的不大于当前爱心指数的家庭编号。即对于每一个树枝节点，我们优先比较右儿子和当前爱心指数的大小，如果右儿子小于等于爱心指数，则说明不大于当前爱心指数的最右的点位于当前区间的右子区间。如果右儿子比爱心指数大，但左儿子小，说明在左边。否则，说明不存在比当前爱心指数小的值。而且在每一次查询后，已经帮助过的家庭的操心指数要设置为 $INF$，防止重复查询。接下来就是每天的模拟操作，只需要把每天的帮助家庭户数记录下来，对于每个询问就可以 $O(1)$ 查询了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3fffffff;const int maxn = 1e5 + 10;LL a[maxn], segtree[maxn &lt;&lt; 4], n, m, c, cnt, num, day;LL b[maxn], ans[maxn];void pushup(int now) &#123; segtree[now] = min(segtree[now &lt;&lt; 1], segtree[(now &lt;&lt; 1)|1]);&#125;void build_tree(int l, int r, int now) &#123; if (l == r) &#123; segtree[now] = a[l]; return; &#125; int mid = (l + r)/2; build_tree(l, mid, now &lt;&lt; 1); build_tree(mid + 1, r, (now &lt;&lt; 1)|1); pushup(now);&#125;int query(int l, int r, int tar, int now) &#123; if (l == r) &#123; segtree[now] = INF; return l; &#125; int mid = (l + r)/2, ans = -1; if (segtree[(now &lt;&lt; 1)|1] &lt;= tar) ans = query(mid + 1, r, tar, (now &lt;&lt; 1)|1); else if (segtree[now &lt;&lt; 1] &lt;= tar) ans = query(l, mid, tar, now &lt;&lt; 1); pushup(now); return ans;&#125;int main()&#123; int T; scanf("%d", &amp;T); while (T--) &#123; memset(segtree, 0, sizeof segtree); memset(ans, 0, sizeof ans); memset(a, 0, sizeof a); memset(b, 0, sizeof b); cnt = num = day = 0; scanf("%lld %lld %lld", &amp;n, &amp;m, &amp;c); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;a[i]); &#125; build_tree(1, n, 1); while (num &lt; n) &#123; cnt += c; day++; int k = query(1, n, cnt, 1); while (k != -1) &#123; ans[day]++; cnt -= a[k]; k = query(1, n, cnt, 1); &#125; num += ans[day]; &#125; for (int i = 0; i &lt; m; i++) &#123; scanf("%lld", &amp;c); printf("%lld\n", c &gt; day? 0 : ans[c]); &#125; &#125; return 0;&#125; K、66..6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by Amon tag：数论。欧拉函数、欧拉定理 设输入的数字为 $p$，即题目的要求得一个长度为 $x$ 的 $66…6$，使得 $66…6 = kp\ (k\in Z)$。可以发现，长度为 $x$ 的 $66…6$ 可以表示为 $\frac{6(10^x - 1)}{9}$。所以我们可以得到式子\frac{6(10^x - 1)}{9} = kp即6(10^x - 1) = 9kp为了可以继续化简，我们假设 $g = gcd(6,9p)$，两边同除 $g$。得 \frac{6(10^x - 1)}{g} = \frac{9kp}{g}此时$\frac{6}{g}$ 与 $\frac{9kp}{g}$ 互质，式子可简化为10^x - 1 = \frac{9kp}{g}即求解 10^x ≡ 1\ (mod\ \frac{9kp}{g})根据欧拉定理可知，最小的 $x$ 存在于 $\varphi(\frac{9kp}{g})$ 的因子中，接下来的任务就是枚举所有 $\varphi(\frac{9kp}{g})$ 的因子，从而找到一个最小的 $x$ 满足 $10^x ≡ 1\ (mod\ \frac{9kp}{g})$。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// sustoj 1908#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;time.h&gt;#include &lt;cstdlib&gt;using namespace std;typedef long long LL;// 求解欧拉函数LL phi(LL x) &#123; LL ans = x; for (LL i = 2; i * i &lt;= x; ++i) &#123; if (x % i == 0) &#123; ans = ans / i * (i - 1); while (x % i == 0) &#123; x /= i; &#125; &#125; &#125; if (x &gt; 1) &#123; ans = ans / x * (x - 1); &#125; return ans;&#125;// 快速乘LL multi(LL a, LL b, LL mod) &#123; LL ret = 0; while (b) &#123; if (b &amp; 1) &#123; ret = (ret + a) % mod; &#125; a = (a &lt;&lt; 1) % mod; b &gt;&gt;= 1; &#125; return ret;&#125;// 快速幂LL fastpow(LL a, LL b, LL p) &#123; LL ans = 1; while (b) &#123; if (b &amp; 1) &#123; ans = multi(ans, a, p); &#125; a = multi(a, a, p); b &gt;&gt;= 1; &#125; return ans;&#125;// 求解最大公约数LL gcd(LL a, LL b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;int main() &#123; LL p; int ca = 1; while (~scanf("%lld", &amp;p) &amp;&amp; p) &#123; printf("Case %d: ", ca++); p /= gcd(p, 6); // p 和 6 有最大公约数，先约去这个数，此时原题变为了 111...111 可以被 p 整除 p *= 9; // 此时原题变为了 999...999 可以被 p 整除，即 100...000 - 1 可以被 p 整除 // 也就是说，100...000 % p 余 1，求最少有多少个 0 // 已知以下定理： // 若正整数 a, p 互质，则满足 a ^ x ≡ 1 (mod p) 的最小的正整数 x0， 是 φ(p) 的约数（因子）。 // φ(p) 为 欧拉函数，即 10^x ≡ 1 (mod p) 的最小的正整数解是 φ(p) 的因子 if (gcd(p, 10) == 1) &#123; // 互质 LL ans = phi(p); // 欧拉函数 LL i = 0; int f = 0; LL tmp = sqrt(ans); // 下面这样求主要是将 O(n) 变为 O(根号n) // ans = φ(p)，求 ans 的因子 for (i = 1; i * i &lt;= ans; ++i) &#123; // 解在 1 - sqrt(ans) 内 if (ans % i == 0) &#123; if (fastpow(10, i, p) == 1) &#123; f = 1; break; &#125; &#125; &#125; if (f) &#123; printf("%lld\n", i); &#125; else &#123; // 解在 sqrt(ans) - ans 内 for (i = tmp; i &gt;= 1; --i) &#123; if (ans % (ans / i) == 0) &#123; if (fastpow(10, ans / i, p) == 1) &#123; break; &#125; &#125; &#125; printf("%lld\n", ans / i); &#125; &#125; else &#123; // 不互质，则无解 printf("-1\n"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】分数化小数(无限循环小数计数 欧拉函数 循环节 十进制 欧拉定理)]]></title>
    <url>%2F2018%2F09%2F25%2F39-%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF%E5%B0%8F%E6%95%B0%2F</url>
    <content type="text"><![CDATA[分数化小数题目描述 对于一个分数（不一定是最简形式），给出它的小树形式，如果小数有循环节的话，把循环节放在一对圆括号中.例如，1/4 =0.25,1/3=0.3333写成0.(3)，1/7=0.142857142857...写成0.(142857)。如果结果是一种整数xxx，则用xxx.0 等表示整数xxx。输入包括一行，包括被空格分隔开的分子N和分母D（第一个是N，第二个是D）。输出包括一行，为转换后的小数形式。 输入样例 45 56 输出样例 0.803(571428) 题目解释题目中需要求一个 分数 的小数，如果是无限循环小数，则输出 0.xxx(xxx) 的格式。因此我们考虑，先求出这个小数的 循环起始点(S) 和 循环长度(T)。 我们举个栗子。对于 $ x = \frac{45}{56} $ 这种情况。我们考虑先对 $x * 10$ 即： $\frac{45}{46},\frac{450}{46},\frac{4500}{46},\frac{45000}{46}\cdots$然后我们将这些分数进行 模 46 操作， 即： \frac{45}{46},\frac{2}{46},\frac{20}{46},\frac{32}{46},\frac{40}{46},\frac{8}{46},\frac{24}{46},\frac{16}{46},\frac{48}{46},\frac{32}{46},\frac{40}{46}我们可以明显的发现当操作进行到第 10 次的时候和第 4 次重复了，显然已经形成了一个长度为 6 的循环节，即从第 4 项开始循环。 由此我们可以推广到更一般的情况，假设存在 $\frac{p}{q}$由于小数部分和整数无关，因此我们可以假设这个分数为真分数。不妨假设$p&gt;q$。 由上可知，我们可以把第 $k$ 个分数写成\frac{p*10^k\ mod\ q}{q}因此我们可以假设第 $i$ 个分数和第 $j$ 个分数相等，即构成了一个循环节。有\frac{p*10^j mod\ q}{q} = \frac{p*10^j mod\ q}{q}即p * 10^j ≡ p * 10^i (mod \ q) \quad (i < j)又可表示为 p*10^j = p*10^i + q*k令 $g = gcd(p,q)$，设 $p = p’g$ , $q=q’g$ 。即 p' *10^j - p'*10^i=q'*k即p'(10^j-10^i) = q'*k \ →\ p'*10^i(10^{j - i} - 1) = q'k由此可知q'|10^i(10^{j - i} - 1)p'因为 $p’$ 和 $q’$ 互质，因此可得$q’|10^i(10^{j - i} - 1)$。由于 $10^i$ 为偶数，且 $(10^{j - i} - 1)$ 为奇数。显然 $i$ 由 $10^i$ 和 $q’$ 共同决定。又知 $10^i$ 和 $q’$ 由 $2$ 和 $5$ 贡献。因此 $i = max(n,m)$,$n$ 为 $q’$中贡献的 $5$ 的个数， $m$ 为 $q’$中贡献的 $10$ 的个数。 接下来需要求循环节 $T = j - i$。 设 q'' = \frac{q'}{5^n*10^m}经过一番计算，上式 $q’|10^i(10^{j - i} - 1)$ 已经变成了q'|5^n10^m(10^{j - i} - 1)*\frac{10^i}{5^n10^m}即q''|(10^{j - i} - 1)*\frac{10^i}{5^n10^m}又知 $q’’$ 与 $\frac{10^i}{5^n10^m}$ 互质。式子可化简为q''|(10^{j - i} - 1)只需要解出 $j -i$ 就是我们无限循环小数中的循环节了。即 10^{j - i}≡1\ (mod\ q'')不妨假设 $x = j - i$，即解10^x≡1\ (mod\ q'')由欧拉定理可知，存在最小的 $10^x≡1\ (mod\ q’’)$ ，当 $x$ 是 $\varphi(q’’)$ 的一个因子。因此我们只需要去枚举所有 $\varphi(q’’)$ 的因子，从而找到一个最小的 $x$，使得 $10^x≡1\ (mod\ q’’)$。 此时解出的 $i$ 就是循环节开始的前一位，$x$ 即 $j - i$ 为循环节的长度。接下来的任务只需要模拟乘法，按照题目要求输出即可。 但是非常悲伤的事情是，队友暴力模拟 A 了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL p, q, S, T, Z;LL Euler(LL x) &#123; LL ans = x; for (LL i = 2; i * i &lt;= x; i++) &#123; if (x % i == 0) &#123; ans = (ans/i) * (i - 1); while (x % i == 0) x /= i; &#125; &#125; if (x &gt; 1) ans = (ans/x) * (x - 1); return ans;&#125;LL power(LL a, LL x, LL mod) &#123; LL ans = 1; while (x) &#123; if (x &amp; 1) ans = (ans * a)%mod; a = (a * a)%mod; x &gt;&gt;= 1; &#125; return ans;&#125;LL gcd(LL a, LL b) &#123; return b == 0? a:gcd(b, a%b);&#125;LL get_first(LL &amp;x) &#123; LL ans1 = 0, ans2 = 0; while (x % 2 == 0) &#123; x /= 2; ans1++; &#125; while (x % 5 == 0) &#123; x /= 5; ans2++; &#125; return max(ans1, ans2);&#125;LL get_T(LL x, LL mod) &#123; LL Min = 1e18; for (LL i = 1; i * i &lt;= x; i++) &#123; if (x % i == 0) &#123; if (power(10, i, mod) == 1) &#123;Min = min(Min, i); break;&#125; if (power(10, x/i, mod) == 1) Min = min(Min, x/i); &#125; &#125; return Min;&#125;void print(LL p, LL q, LL S, LL T) &#123; printf("%lld.", p/q); p -= q * (p/q); for (int i = 0; i &lt; S + T; i++) &#123; if (i == S) printf("("); p *= 10; printf("%lld", p/q); p -= q * (p/q); if (p == 0) break; if (i == S + T - 1) printf(")"); &#125; printf("\n");&#125;int main()&#123; while (scanf("%lld %lld", &amp;p, &amp;q) != EOF) &#123; LL a = p, b = q; LL g = gcd(p, q); p /= g, q /= g; S = get_first(q); LL phi = Euler(q); T = get_T(phi, q); if (T == 1e18) S = T; print(a, b, S, T); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018暑期集训7.19习题题解]]></title>
    <url>%2F2018%2F07%2F19%2F7.19summertraining%2F</url>
    <content type="text"><![CDATA[2018暑期集训7.19习题题解 A(Alice和Bob的决斗)1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int t,n; int a[10000]; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(int i = 0;i &lt; n; i++)&#123; scanf("%d",&amp;a[i]); &#125; sort(a,a + n); if(a[n/2]%2 == 0) printf("Alice\n"); else printf("Bob\n"); &#125; return 0;&#125; B(小程四级高分过)123456789101112131415161718#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char a[11][10] = &#123;"Zero","One","Two","Three","Four","Five","Six","Seven","Eight","Nine","Ten"&#125;;int main()&#123; char s[10]; while(scanf("%s",s) != EOF)&#123; for(int i = 0;i &lt; 11; i++)&#123; if(strcmp(a[i],s) == 0)&#123; printf("%d\n",i); break; &#125; &#125; &#125; return 0;&#125; C(美丽校园——绿化)12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;const int maxn = 1005;int a[maxn][maxn];int main()&#123; int n,m,k; while(scanf("%d%d%d",&amp;n,&amp;m,&amp;k) != EOF &amp;&amp; (n||m||k))&#123; for(int i = 0;i &lt; maxn; i++)&#123; fill(a[i],a[i] + maxn, 0); &#125; int x1,x2,y1,y2,cnt = 0; for(int i = 0;i &lt; k; i++)&#123; scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); for(int x = x1 - 1;x &lt; x2; x++)&#123; for(int y = y1 - 1;y &lt; y2; y++)&#123; a[x][y] = 1; &#125; &#125; &#125; for(int i = 0;i &lt; n; i++)&#123; for(int j = 0;j &lt; m; j++)&#123; if(a[i][j] == 1) cnt++; &#125; &#125; printf("%d\n",cnt); &#125; return 0;&#125; D(括号匹配)1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1005;int main()&#123; char s[maxn]; while(gets(s) != NULL)&#123; int cnt = 0,flag = 1,len = strlen(s); for(int i = 0;i &lt; len; i++)&#123; if(s[i] == '(') cnt++; else if(s[i] == ')')&#123; if(cnt == 0)&#123; flag = 0; break; &#125;else if(cnt &gt; 0)&#123; cnt--; &#125; &#125; &#125; if(flag == 0 || cnt &gt; 0) printf("No\n"); else printf("Yes\n"); &#125; return 0;&#125; E(复原二叉树)123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef struct node&#123; char c; struct node *lchild,*rchild;&#125;tree;tree* findtree(char *pre,char *in,int len)&#123; if(len == 0) return NULL; tree *temp = new tree; temp-&gt;c = *pre; int i = 0; for(i = 0;i &lt; len; i++)&#123; if(*(in + i) == *pre)&#123; break; &#125; &#125; temp-&gt;lchild = findtree(pre + 1,in,i); temp-&gt;rchild = findtree(pre + i + 1,in + i + 1,len - i - 1); return temp;&#125;void output(tree* now)&#123; if(now != NULL)&#123; output(now-&gt;lchild); output(now-&gt;rchild); printf("%c",now-&gt;c); &#125;&#125;int main()&#123; char pre[1005],in[1005]; while(scanf("%s %s",pre,in) != EOF)&#123; tree *root = findtree(pre,in,strlen(pre)); output(root); printf("\n"); &#125; return 0;&#125; F(空心三角形)12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int main()&#123; char a; int i,j,k=0,n; scanf("%c",&amp;a); while (a!='@') &#123; scanf("%d",&amp;n); if(k!=0) printf("\n"); for (i=0;i&lt;n-1;i++) &#123; for (j=1;j&lt;n+i;j++) if((n-j)%n==i) printf("%c",a); else printf(" "); printf("%c\n",a); &#125; n=n*2-1; while(n--) printf("%c",a); printf("\n"); k++; getchar(); scanf("%c",&amp;a); &#125; return 0;&#125; G(这层树海星)1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;const int maxn = 1005;int a[maxn];int main()&#123; int n,d; while(scanf("%d",&amp;n) &amp;&amp; n != 0)&#123; fill(a,a + maxn, -1); for(int i = 1;i &lt;= n; i++)&#123; scanf("%d",&amp;a[i]); &#125; scanf("%d",&amp;d); for(int i = pow(2,d - 1);i &lt; pow(2,d); i++)&#123; if(a[i] == -1)&#123; if(i == pow(2,d - 1)) printf("EMPTY"); break; &#125;else&#123; if(i == pow(2,d - 1))printf("%d",a[i]); else printf(" %d",a[i]); &#125; &#125; printf("\n"); &#125; return 0;&#125; H(愿天下有情人都是失散多年的兄妹)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;const int maxn = 100005;struct node&#123; int dad,mom; char sex; node(char a = 0,int b = -1,int c = -1)&#123;sex = a,dad = b,mom = b;&#125;&#125;p[maxn];bool have[maxn],vis[maxn],flag;char sex[maxn];void find(int n,int x)&#123; if(x == 5)&#123; return; &#125; if(n != -1 &amp;&amp; have[n] == true)&#123; vis[n] = true; find(p[n].dad,x + 1); find(p[n].mom,x + 1); &#125;&#125;void judge(int n,int x)&#123; if(x == 5) return; if(n != -1 &amp;&amp; flag == true &amp;&amp; have[n] == true)&#123; if(vis[n] == true)&#123; flag = false; return; &#125;else&#123; judge(p[n].dad,x + 1); judge(p[n].mom,x + 1); &#125; &#125;&#125;int main()&#123; int n,k; scanf("%d",&amp;n); fill(have,have + maxn, false); int my,f,m; char sex[5]; for(int i = 0;i &lt; n; i++)&#123; scanf("%d %s %d %d",&amp;my,sex,&amp;f,&amp;m); p[my].sex = sex[0]; p[my].dad = f; p[my].mom = m; have[my] = have[f] = have[m] = true; p[f].sex = 'M'; p[m].sex = 'F'; &#125; int a,b; scanf("%d",&amp;k); for(int i = 0;i &lt; k; i++)&#123; scanf("%d %d",&amp;a,&amp;b); if(p[a].sex == p[b].sex)&#123; printf("Never Mind\n"); &#125;else&#123; fill(vis,vis + maxn, false); find(a,0); flag = true; judge(b,0); if(flag == false)&#123; printf("No\n"); &#125;else&#123; printf("Yes\n"); &#125; &#125; &#125; return 0;&#125; I(最高分是多少)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 30005;int a[maxn],tree[(maxn&lt;&lt;4)+5];void creattree(int l,int r,int now)&#123; if(l == r)&#123; tree[now] = a[l]; return; &#125; int mid = (l + r)/2; creattree(l,mid,now &lt;&lt; 1); creattree(mid + 1,r,(now &lt;&lt; 1) + 1); tree[now] = max(tree[now &lt;&lt; 1],tree[(now &lt;&lt; 1) + 1]);&#125;void change(int l,int r,int x,int y,int now)&#123; if(l == r)&#123; tree[now] = y; return; &#125; int mid = (l + r)/2; if(x &lt;= mid) change(l,mid,x,y,now &lt;&lt; 1); else change(mid + 1,r,x,y,(now &lt;&lt; 1) + 1); tree[now] = max(tree[now &lt;&lt; 1],tree[(now &lt;&lt; 1) + 1]);&#125;int find(int l,int r,int x,int y,int now)&#123; if(l &gt;= x &amp;&amp; r &lt;= y)&#123; return tree[now]; &#125; int ans = 0,mid = (r + l)/2; if(x &lt;= mid) ans = max(ans,find(l,mid,x,y,now &lt;&lt; 1)); if(y &gt; mid) ans = max(ans,find(mid + 1,r,x,y,(now &lt;&lt; 1) + 1)); return ans;&#125;int main()&#123; int n,m,x,y; char s[5]; while(scanf("%d %d",&amp;n,&amp;m) != EOF)&#123; for(int i = 1;i &lt;= n; i++)&#123; scanf("%d",&amp;a[i]); &#125; creattree(1,n,1); for(int i = 0;i &lt; m; i++)&#123; scanf("%s %d %d",s,&amp;x,&amp;y); if(s[0] == 'U')&#123; change(1,n,x,y,1); &#125;else if(s[0] == 'Q')&#123; printf("%d\n",find(1,n,x,y,1)); &#125; &#125; &#125; return 0;&#125; J(Maximum Element In A Stack)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 100000;int stack[maxn];int Maxstack[maxn];int stack_top = 0,Maxstack_top = 0;int n,p,q,m,ans = 0;unsigned int SA,SB,SC;unsigned int rng61()&#123; SA ^= SA &lt;&lt; 16; SA ^= SA &gt;&gt; 5; SA ^= SA &lt;&lt; 1; unsigned int t = SA; SA = SB; SB = SC; SC ^= t ^ SA; return SC; &#125; void gen()&#123; scanf("%d%d%d%d%u%u%u",&amp;n,&amp;p,&amp;q,&amp;m,&amp;SA,&amp;SB,&amp;SC); for(int i = 1; i &lt;= n; i++)&#123; if(rng61() % (p + q) &lt; p)&#123; int x = rng61() % m + 1; stack[stack_top++] = x; if(Maxstack_top == 0 ||(Maxstack_top != 0 &amp;&amp; x &gt;= Maxstack[Maxstack_top - 1]))&#123; Maxstack[Maxstack_top++] = x; &#125; &#125;else&#123; if(stack_top != 0) &#123; stack_top--; if(stack[stack_top] == Maxstack[Maxstack_top - 1]) Maxstack_top--; &#125; &#125; if(stack_top != 0) ans ^= (i*Maxstack[Maxstack_top - 1]); &#125;&#125;int main()&#123; int t; scanf("%d",&amp;t); for(int x = 1;x &lt;= t; x++)&#123; ans = 0,stack_top = 0,Maxstack_top = 0; gen(); printf("Case #%d: %d\n",x,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>总结</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年ICPC-ACM全国大学生程序设计竞赛(宁夏) 总结]]></title>
    <url>%2F2018%2F07%2F08%2F2018ningxiaACM%2F</url>
    <content type="text"><![CDATA[前言这是我在大一参加的第二场ACM，总之非常感谢齐老师和队友以及各位大佬。最后拿到了铜牌，虽然不大，也很辣鸡，但是还是很开心，ACM的第一个奖。接下来的目标当然是邀请赛银区域赛铜啦，这个目标还是挺小的。 6月8日 星期五出发今天5点半起的床，很快就准备好了，去6公寓坐高级商务7座的奔驰车，哈哈。美中不足的是正在下雨。 机场到达机场的时候已经快要7点了，飞机是8点25的，只在机场没过多久，就开始登机了。 落地落地的时候将近10点了，我们出到接机大厅，就看到了拿个海报接机的一个小哥哥小姐姐（渣渣辉说小姐姐长得很漂亮）。然后小哥哥带我们坐摆渡车去停车场上大巴。等到差不多12点满员才出发，在车上，我打到了QQ飞车的街区车王第二名(第一名太厉害了%)。 宁夏理工学院在大巴这里一路上，看到了“沙湖”，就是一个简单的湖，后来发现并不是这样哈哈。到达了宁夏理工学院，大巴停车在咱们宿舍楼的门前，学校很有诚意，我们入住了宁夏理工学院的条件最好的大楼之一。在办理了简单入住之后，我们住进了我们的宿舍，四人间(三个床铺铺上了床上用品)。宿舍非常好，上床下桌，就是没有风扇没有空调。(听说平时不热，只是我们来的这两天热，可能不太幸运，晚上热得贴着墙睡觉)。学校给发了90块钱的餐票，所以我们先去饭堂搓了一顿，并打算睡一觉后晚上去吃顿烧烤。 初识教练睡完觉后，已经下午了，咱们准备出去撸串。当我们走在饭堂楼下时，一个女生过来问我们是不是参赛队伍。我们是支有素质的队伍，当然邀请人家共进撸串。于是这个小姐姐和咱们撸串，介绍宁夏理工还有宁夏的一些情况。第一次看见九点多了天都没黑。与此同时，咱们密谋着如何把她带入第二天的旅游项目中，于是漂亮小姐姐便成为了咱们教练(齐老师会怎么想呢？哈哈哈)。晚上送教练回到宿舍后，我们也回了宿舍，去体验宁夏理工的澡堂。果然澡堂比我学校好太多啦！ 睡觉于是咱们睡觉啦，等待第二天的旅游。 6月9日 星期六未完待续]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年ICPC-ACM全国邀请赛(西安) 总结]]></title>
    <url>%2F2018%2F05%2F26%2Fxi'an2018ICPC-2018%2F</url>
    <content type="text"><![CDATA[前言这次ACM是第一战，很感谢能在大一就参加acm。本来想着要拿铜，但是还是打了铁。除了自己的能力问题，当然也有一大部分是题目的问题(疯狂改题);出题人:虽然题目有问题，但是我不在呀=-= 5月19日出发前一天5.18参加了班聚轰趴，通宵了，所以当天睡眠时间少于两小时。本来很害怕状态不好的，后来发现多虑了，状态一直在线上。早上10点从学校出发，司机不太认路，大概一个小时多一点到了西工大。 签到 &amp; 拍照 &amp; 开幕式在实验楼有很多绿色衣服的小姐姐(知乎上很多人赞这点)。签到的时候领了一件蓝色acmT恤。换上了之后和队友在acm黑色背景下拍照;然后到门口acm大广告牌拍了一张集体照。然后再去吃饭。比4C要好的是，可以领一瓶饮料。但是每次都是一样的饭菜呀？吃完后咱们就去开幕式，一开始去学生中心，被告知场地有冲突，安排去了体育馆。于是我们在体育馆门口静坐了一个多小时。进去之后看了开幕式(麦声音太小，不知道说了啥)。 热身赛热身赛的所有题都没写范围！！！A题一看就直接在线就可以了。结果WA了;然后离线再来一次，再WA;后来第一题改题意，(改题意之前，就只有几个队A了，广播更改后，130+个队A了…一瞬间);但是…我们还是没A，WA了3次之后发现是浮点数/4没有/4.0所以WA了；BC都没做… 5月20日出发早上7点出发，比昨天顺利了一点，因为司机认路了； 正赛在机房门口等了一会就进场了。很多队把头文件都打好了(包括我们)，后来按照要求重启了，等到时间到了再开机XDA题是最早看的题，广播疯狂改题意(虽然题目有问题，但是出题人不在呀。)比赛过了一半，终于把题意掰正了。但是我还是一脸懵逼，幸好队友理解了；在比赛20分钟时，第一次看榜，发现E题一百多个A了，马上开E题，题意秒懂，上机敲。WA了三次，因为”No”写成了”NO”！！！罚时一个小时。很亏呀于是看榜，D题也很多队做了。于是开了D题，队友理解错了，然后我来推了一下，以为公式是对了，最后WA了n次，在比赛结束前45分钟才发现漏洞。但是水平有限，一直到结束都退不出正确的SG公式。隔壁天津大学的女队很强。一开始我们以为可以跟着她们，因为看起来咱们速度差不多。后来才发现…我们不一样,不一样…因为她们连A了3题,于是ADEG冲银夺得了最佳女队。实在羡慕。 总结总的来讲，水平还是不够，当然我也想赖一下题目不好。而且很粗心。等6月的宁夏赛和年底的亚洲区域赛吧~]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(38)】Frogger POJ-2253]]></title>
    <url>%2F2018%2F04%2F26%2F38-froggerpoj2253%2F</url>
    <content type="text"><![CDATA[Frogger POJ-2253 Freddy Frog is sitting on a stone in the middle of a lake. Suddenly he notices Fiona Frog who is sitting on another stone. He plans to visit her, but since the water is dirty and full of tourists’ sunscreen, he wants to avoid swimming and instead reach her by jumping.Unfortunately Fiona’s stone is out of his jump range. Therefore Freddy considers to use other stones as intermediate stops and reach her by a sequence of several small jumps.To execute a given sequence of jumps, a frog’s jump range obviously must be at least as long as the longest jump occuring in the sequence.The frog distance (humans also call it minimax distance) between two stones therefore is defined as the minimum necessary jump range over all possible paths between the two stones. You are given the coordinates of Freddy’s stone, Fiona’s stone and all other stones in the lake. Your job is to compute the frog distance between Freddy’s and Fiona’s stone. Input The input will contain one or more test cases. The first line of each test case will contain the number of stones n (2&lt;=n&lt;=200). The next n lines each contain two integers xi,yi (0 &lt;= xi,yi &lt;= 1000) representing the coordinates of stone #i. Stone #1 is Freddy’s stone, stone #2 is Fiona’s stone, the other n-2 stones are unoccupied. There’s a blank line following each test case. Input is terminated by a value of zero (0) for n. Output For each test case, print a line saying “Scenario #x” and a line saying “Frog Distance = y” where x is replaced by the test case number (they are numbered from 1) and y is replaced by the appropriate real number, printed to three decimals. Put a blank line after each test case, even after the last one. Sample Input 20 03 4 317 419 418 5 0 Sample Output Scenario #1Frog Distance = 5.000 Scenario #2Frog Distance = 1.414 题解 题意是,第一个石子是出发地,第二个石子是目的地，求两者间所有路径的最大值的最小值例如有三条路 3→4→2→6→4 最大值是 6 5→3→7→4 最大值是 7 4→1→5→3→2 最大值是 5 于是,各个路径的最大值的最小值就是 5 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;#define INF 0x3fffffff#define maxn 205double mp[maxn][maxn],path[maxn];//mp存储两点间距离，path存从起点到i点的最大距离的最小值bool flag[maxn];//标记是否被访问过int n,cnt = 1;map&lt;int,pair&lt;int,int&gt; &gt; m;//map存储点的x和ystruct node&#123; int num;double dis;//num存储石头编号，dis存从起点到num石头的最大距离的最小值 node(int a,double b)&#123;//初始化函数 num = a;dis = b; &#125; bool friend operator &lt; (node a, node b)&#123;//优先队列重载 &lt; return a.dis &gt; b.dis; &#125;&#125;;double dis(int a,int b)&#123;//两点间距离函数 return sqrt(pow((double)(m[a].first - m[b].first),2) + pow((double)(m[a].second - m[b].second),2));&#125;void dijkstra()&#123; priority_queue&lt;node&gt; q;//堆优化dijkstra node start(0,0);//把第一个起点加入队列 path[0] = 0; q.push(start); while(!q.empty())&#123; node p = q.top();q.pop(); if(flag[p.num] == true) continue; flag[p.num] = true; for(int i = 0;i &lt; n; i++)&#123; if(path[i] &gt; max(mp[i][p.num],path[p.num]) &amp;&amp; flag[i] == false)&#123; path[i] = max(mp[i][p.num],path[p.num]);//更新path数组 node temp(i,path[i]); q.push(temp); &#125; &#125; &#125;&#125;int main()&#123; while(scanf("%d",&amp;n) != EOF &amp;&amp; n)&#123; for(int i = 0;i &lt; maxn; i++)&#123; fill(mp[i],mp[i] + maxn, INF);//初始化 mp[i][i] = 0; &#125; fill(path,path + maxn, INF);//初始化 fill(flag,flag + maxn, false);//初始化 for(int i = 0;i &lt; n; i++)&#123;//map对于石头编号i到x,y的映射 scanf("%d %d",&amp;m[i].first,&amp;m[i].second); for(int j = 0;j &lt; i; j++)&#123; mp[i][j] = mp[j][i] = dis(i,j);//计算两点间距离 &#125; &#125; dijkstra(); printf("Scenario #%d\n",cnt); printf("Frog Distance = %.3f\n\n",path[1]); cnt++; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(37)】最短路 HDU-2544 (dijkstra + 堆优化)]]></title>
    <url>%2F2018%2F04%2F24%2F37-dijkstra%2F</url>
    <content type="text"><![CDATA[最短路 HDU-2544 在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？ Input 输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。输入保证至少存在1条商店到赛场的路线。 Output 对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间 Sample Input 2 11 2 33 31 2 52 3 53 1 20 0 Sample Output 32 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;#define INF 0x3fffffff#define maxn 105int mp[maxn][maxn],dis[maxn];bool flag[maxn];typedef struct node&#123; int i,v; node(int a,int b)&#123; i = a;v = b; &#125; friend bool operator &lt; (node a,node b)&#123; return a.v &gt; b.v; &#125;&#125;creatnode;int main()&#123; int n,m; while(cin &gt;&gt; n &gt;&gt; m)&#123; if(!n &amp;&amp; !m) break; priority_queue&lt;creatnode&gt; q; for(int i = 0;i &lt;= n; i++)&#123; fill(mp[i],mp[i] + maxn, INF); mp[i][i] = 0;dis[i] = INF;flag[i] = false; &#125; for(int i = 0;i &lt; m; i++)&#123; int f1,f2,v; cin &gt;&gt; f1 &gt;&gt; f2 &gt;&gt; v; mp[f2][f1] = mp[f1][f2] = v; &#125; dis[1] = 0; creatnode path(1,0); q.push(path); while(!q.empty())&#123; creatnode p = q.top();q.pop(); if(flag[p.i] == true) continue; flag[p.i] = true; for(int i = 1;i &lt;= n; i++)&#123; if(flag[i] == false &amp;&amp; dis[i] &gt; p.v + mp[i][p.i])&#123; dis[i] = p.v + mp[i][p.i]; creatnode path(i,dis[i]); q.push(path); &#125; &#125; &#125; cout &lt;&lt; dis[n] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(36)】Sum POJ-1844 (趣题)]]></title>
    <url>%2F2018%2F04%2F23%2F36-sum-quti%2F</url>
    <content type="text"><![CDATA[Sum POJ-1844 Consider the natural numbers from 1 to N. By associating to each number a sign (+ or -) and calculating the value of this expression we obtain a sum S. The problem is to determine for a given sum S the minimum number N for which we can obtain S by associating signs for all numbers between 1 to N.For a given S, find out the minimum value N in order to obtain S according to the conditions of the problem.InputThe only line contains in the first line a positive integer S (0&lt; S &lt;= 100000) which represents the sum to be obtained. Output The output will contain the minimum number N for which the sum S can be obtained. Sample Input 12 Sample Output 7 Hint The sum 12 can be obtained from at least 7 terms in the following way: 12 = -1+2+3+4+5+6-7. 题解 题目大意是，给定一个数字N,让你求出一个最小的S,让1+2+…+S变换某些数字的符号,使得1 ± 2 ± 3 ± … ± S == N所以样例中给出N为12,存在最小S为7,使得1-2+3+4+5-6+7=12; 我们把累加的结果记为Sum,累加的数字个数记为n，变换符号的数字称为ki仔细观察我们会发现 当我们减去一个数字,Sum就会减去这个数字的两倍即 1+2+3+…+k+…+n = Sum当我们把k符号变号 Sum’ = Sum - 2k;举例:1 + 2 + 3 + 4 = 10 → 1 + 2 - 3 + 4 = 4我们把3变成了负的,于是10变成了 10 - 2*3 = 4这是在一个数符号变负的情况。 同样的,我们可以推广出多个数字符号改变的情况 若将 k1,k2…ki的符号都变成负号Sum’ = Sum - 2*(k1+k2+…+ki);例子见题目案例; 所以我们可以把题目要求分为两种情况 ①1 + 2 + … + S == N;即累加刚好等于题目所给N ②Sum &gt; Sum’,即需要在某些数字前变换负号。因为我们已经知道Sum - Sum’ 会是某个数字或某些数字的两倍即Sum - Sum’一定是偶数。反过来，如果Sum - Sum’是偶数,我们总能在1到S中找到一个或一些数字等于(Sum - Sum’)/2于是，我们把这个或这些数字符号变负即可。 代码12345678910111213141516#include&lt;iostream&gt;using namespace std;int main()&#123; int n,sum = 0,i = 0; cin &gt;&gt; n; while(++i)&#123; sum += i; if(n == sum|| (n &lt; sum &amp;&amp; (sum - n)%2 == 0))&#123; cout &lt;&lt; i &lt;&lt; endl; break; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【比特杯-C语言大赛】(2018)比特杯C语言大赛题解]]></title>
    <url>%2F2018%2F04%2F21%2Fsustxiaosaitijie%2F</url>
    <content type="text"><![CDATA[第0题题意 给出一段字符串和一个整数n，输出在字符串中第一次出现n次的字符；例如: abbbcdeee 3 → b 题解 显然，遍历字符串时用count()函数检测该字符的数量，如果等于n，则输出 代码12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,i; bool vis[300];//记录该字符是否被访问过 string str; cin &gt;&gt; str &gt;&gt; n; int len = str.size(); for(i = 0;i &lt; len; i++)&#123; if(vis[(int)str[i]] == false)&#123; vis[(int)str[i]] = true; if(count(str.begin(),str.end(),str[i]) == n)&#123; cout &lt;&lt; str[i] &lt;&lt; endl; break; &#125; &#125; &#125; if(len == i) cout &lt;&lt; "-1" &lt;&lt; endl; return 0;&#125; 第1题题意 题目是要输出一个蛇形上三角矩阵有多组输入样例 输入： 5 输出 1 3 6 10 152 5 9 144 8 137 1211 题解 设矩阵第一个元素是从第0行第0列开始的;我们可以观察到，对于第一列，a[i][0] = a[i][0] + i;然后我们在观察每一行除了第一个元素以外，a[i][j] = a[i][j - 1] + i + j + 1 (i != 0); 代码12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 205int a[maxn][maxn],n;int main()&#123; while(cin &gt;&gt; n)&#123; for(int i = 0;i &lt; n;i++) fill(a[i],a[i] + n,0); a[0][0] = 1; for(int i = 0;i &lt; n; i++)&#123; if(i != 0) a[i][0] = a[i - 1][0] + i; cout &lt;&lt; a[i][0]; for(int j = 1;j &lt; n - i; j++)&#123; a[i][j] = a[i][j - 1] + i + j + 1; cout &lt;&lt; " " &lt;&lt;a[i][j]; &#125; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 第2题题意 第一行输入一个数字n,接下来有n个整数,如果有一个数字出现次数超过n的一半，则输出。否则,输出”-1”。 题解 这道题可以用标准模板库的map来做,建立一个”数字 → 出现次数”的映射。即map m; 代码123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,k,x = 0; cin &gt;&gt; n; map&lt;int,int&gt; m; for(int i = 0;i &lt; n; i++)&#123; cin &gt;&gt; k; if(++m[k] &gt; n/2) x = k; &#125; cout &lt;&lt; x &lt;&lt; endl;; return 0;&#125; 第3题题意 有n个相同苹果和k个相同盘子，问有多少种不同的摆法。例如 7 3 → 8；样例中，4 1 2和4 2 1 视为同一种。部分盘子可以为空。 题解 在数学中，我们可以发现，如果要得到唯一不同的情况，需要第i个盘子装的水果不比第i - 1个盘子多，否则就会造成重复。例如: 7 0 06 1 05 2 05 1 14 3 04 2 13 3 13 2 2 但是，如果出现 4 1 24 0 33 1 3 类似的情况，就会发现存在重复，以为某一个元素存在前一个元素比自身要小。所以我们用搜索来排除这种干扰； 代码123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int n,k,cnt = 0;void dfs(int x,int sum,int num)&#123; if(num &gt; k)&#123; if(sum == n) cnt++; return; &#125; for(int i = x;i &gt;= 0;i--) dfs(i,i + sum,num + 1);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; dfs(n,0,1); cout &lt;&lt; cnt &lt;&lt; endl; return 0;&#125; 后记 本人才疏学浅,若发现问题,望尊指正。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(35)】Dungeon Master POJ - 2251]]></title>
    <url>%2F2018%2F04%2F20%2F35-Dungeon%20Master%2F</url>
    <content type="text"><![CDATA[Dungeon Master Time Limit: 1000MS Memory Limit: 65536KT&gt;otal Submissions: 44032 Accepted: 16602 Description You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides.Is an escape possible? If yes, how long will it take? Input The input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).L is the number of levels making up the dungeon.R and C are the number of rows and columns making up the plan of each level.Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a ‘#’ and empty cells are represented by a ‘.’. Your starting position is indicated by ‘S’ and the exit by the letter ‘E’. There’s a single blank line after each level. Input is terminated by three zeroes for L, R and C. Output Each maze generates one line of output. If it is possible to reach the exit, print a line of the formEscaped in x minute(s). where x is replaced by the shortest time it takes to escape.If it is not possible to escape, print the lineTrapped! Sample Input 3 4 5S…..###..##.. . ##.… ##.E 1 3 3S## E# 0 0 0 Sample Output Escaped in 11 minute(s).Trapped! 题解 题中可以了解到，这道题是一个三维的bfs，和二维一样，只不过在二维的基础上多了一个z坐标轴。所以在广搜时多了 z + 1 和 z - 1两个两个条件，其余的都一样。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;#define maxn 31char mp[maxn][maxn][maxn];bool vis[maxn][maxn][maxn];int l,r,c,flag = 0;struct node&#123; int x,y,z,cnt; node(int a,int b,int c,int d)&#123; x = a,y = b,z = c,cnt = d; &#125;&#125;;void bfs(int x,int y,int z)&#123; queue&lt;node&gt; q; node start(x,y,z,0); q.push(start); while(!q.empty())&#123; node p = q.front();q.pop(); if(p.x &lt; l &amp;&amp; p.x &gt;= 0 &amp;&amp; p.y &gt;= 0 &amp;&amp; p.y &lt; r &amp;&amp; p.z &gt;= 0 &amp;&amp; p.z &lt;c)&#123; if(mp[p.x][p.y][p.z] == 'E')&#123; flag = 1; printf("Escaped in %d minute(s).\n",p.cnt); break; &#125;else if(mp[p.x][p.y][p.z] != '#' &amp;&amp; vis[p.x][p.y][p.z] == false)&#123; vis[p.x][p.y][p.z] = true; &#123;node temp(p.x + 1,p.y,p.z,p.cnt + 1);q.push(temp);&#125; &#123;node temp(p.x - 1,p.y,p.z,p.cnt + 1);q.push(temp);&#125; &#123;node temp(p.x,p.y + 1,p.z,p.cnt + 1);q.push(temp);&#125; &#123;node temp(p.x,p.y - 1,p.z,p.cnt + 1);q.push(temp);&#125; &#123;node temp(p.x,p.y,p.z + 1,p.cnt + 1);q.push(temp);&#125; &#123;node temp(p.x,p.y,p.z - 1,p.cnt + 1);q.push(temp);&#125; &#125; &#125; &#125;&#125;int main()&#123; while(scanf("%d %d %d",&amp;l,&amp;r,&amp;c) != EOF)&#123; if(!l &amp;&amp; !r &amp;&amp; !c) break; for(int i = 0;i &lt; l; i++)&#123; getchar(); for(int j = 0;j &lt; r; j++)&#123; fill(vis[i][j],vis[i][j] + c + 1, false); gets(mp[i][j]); &#125; &#125; for(int i = 0;i &lt; l; i++)&#123; for(int j = 0;j &lt; r; j++)&#123; for(int k = 0;k &lt; c; k++)&#123; if(mp[i][j][k] == 'S')&#123; flag = 0; bfs(i,j,k); break; &#125; &#125; &#125; &#125; if(flag == 0) printf("Trapped!\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(34)】Halloween Costumes LightOJ-1422]]></title>
    <url>%2F2018%2F04%2F17%2F34-HalloweenCostumes-lightoj-3422%2F</url>
    <content type="text"><![CDATA[Halloween Costumes LightOJ-1422 Gappu has a very busy weekend ahead of him. Because, next weekend is Halloween, and he is planning to attend as many parties as he can. Since it’s Halloween, these parties are all costume parties, Gappu always selects his costumes in such a way that it blends with his friends, that is, when he is attending the party, arranged by his comic-book-fan friends, he will go with the costume of Superman, but when the party is arranged contest-buddies, he would go with the costume of ‘Chinese Postman’. Since he is going to attend a number of parties on the Halloween night, and wear costumes accordingly, he will be changing his costumes a number of times. So, to make things a little easier, he may put on costumes one over another (that is he may wear the uniform for the postman, over the superman costume). Before each party he can take off some of the costumes, or wear a new one. That is, if he is wearing the Postman uniform over the Superman costume, and wants to go to a party in Superman costume, he can take off the Postman uniform, or he can wear a new Superman uniform. But, keep in mind that, Gappu doesn’t like to wear dresses without cleaning them first, so, after taking off the Postman uniform, he cannot use that again in the Halloween night, if he needs the Postman costume again, he will have to use a new one. He can take off any number of costumes, and if he takes off k of the costumes, that will be the last k ones (e.g. if he wears costume A before costume B, to take off A, first he has to remove B). Given the parties and the costumes, find the minimum number of costumes Gappu will need in the Halloween night. Input Input starts with an integer T (≤ 200), denoting the number of test cases. Each case starts with a line containing an integer N (1 ≤ N ≤ 100) denoting the number of parties. Next line contains N integers, where the ith integer ci (1 ≤ ci ≤ 100) denotes the costume he will be wearing in party i. He will attend party 1 first, then party 2, and so on. Output For each case, print the case number and the minimum number of required costumes. Sample Input 241 2 1 271 2 1 1 3 2 1 Sample Output Case 1: 3Case 2: 4 题解 解释一下题意:题目说，那个人要去参加很多场万圣节派对，而且很多排队的主题不同，也意味着穿的衣服也可能不同。但是这个小伙子又忙又懒，他可以穿很多层衣服去参加很多场排队。例如有一场编号为1，2的派对，他可以里面穿着2的衣服，外面穿着1的衣服。去到参加2号排队时，把外面的衣服脱了就行。但是这个小伙子不喜欢穿脏衣服，也不会洗衣服。所以脱下来的衣服不能再穿上去。于是题目的问题是，给定不同编号的派对，问你他需要准备至少多少件衣服。 这个题是区间dp的问题，所以我们可以用形似 dp[i][j] = min{dp[i][j],dp[i][k] + dp[k + 1][j] + w[i][j]}; 的状态转移式来写。 我们用dp[i][j]表示从第i到第j场需要准备的衣服于是，当在第j场时，如果他新穿一件衣服，即dp[i][j] = dp[i][j - 1] + 1;如果，如果他不新穿一件，就要找到与第j场穿同样衣服的场次k。当找到穿同意衣服的场次k，意味着他的第j场的衣服要在第k场保留到第j场。即在第k场后穿的衣服，要在第j场前全部脱掉，这样子才可以把第j场的衣服漏出来；即 dp[i][j] = dp[i][k] + dp[k + 1][j - 1]; 代码123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;#define maxn 105int dp[maxn][maxn],a[maxn];int main()&#123; int T; cin &gt;&gt; T; for(int x = 1; x &lt;= T; x++)&#123; cin &gt;&gt; a[0]; for(int i = 1;i &lt;= a[0]; i++)&#123; cin &gt;&gt; a[i]; fill(dp[i],dp[i] + a[0] + 1, 0); dp[i][i] = 1; &#125; for(int len = 2; len &lt;= a[0]; len++)&#123; for(int i = 1,j;(j = i + len - 1) &lt;= a[0]; i++)&#123; dp[i][j] = dp[i][j - 1] + 1; for(int k = i;k &lt; j; k++)&#123; if(a[k] == a[j])&#123; dp[i][j] = min(dp[i][j],dp[i][k] + dp[k + 1][j - 1]); &#125; &#125; &#125; &#125; cout &lt;&lt; "Case " &lt;&lt; x &lt;&lt; ": " &lt;&lt; dp[1][a[0]] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(33)】敌兵布阵 HDU-1166(线段树)]]></title>
    <url>%2F2018%2F04%2F08%2F33-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5%2F</url>
    <content type="text"><![CDATA[敌兵布阵 HDU-1166前言 这是赵神5个月前布置的一道题目,VJ上显示第一次提交记录是2017-11-02 22:36:53当时还年轻,以为这个题不难，直接就暴力求解,现在发现太年轻了,线段树+string都TLE五个月前，对线段树最深的了解就是西工大的线段树专场了。这是5个月的回忆,回想这5个月,还是荒废掉了。 题目描述 C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input 第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令 Output 对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。Sample Input1101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10End Sample Output Case 1:63359 题解 这题虽然我很勉强的做出来了，但是的确是线段树的模板题，都怪我太弱鸡。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;const int maxn = 50005;int num[maxn],tree[maxn &lt;&lt; 2];void update(int now)&#123; tree[now] = tree[now &lt;&lt; 1] + tree[(now &lt;&lt; 1)|1];&#125;void build_tree(int l,int r,int now)&#123; if(l == r)&#123; tree[now] = num[l]; return; &#125; int mid = (l + r)/2; build_tree(l,mid,now &lt;&lt; 1); build_tree(mid + 1,r,(now &lt;&lt; 1)|1); update(now);&#125;void change(int l,int r,int now,int tar,int x)&#123;//tree[tar] += x; if(l == r)&#123; tree[now] += x; return; &#125; int mid = (r + l)/2; if(tar &lt;= mid) change(l,mid,now &lt;&lt; 1,tar,x); else change(mid + 1,r,(now &lt;&lt; 1)|1,tar,x); update(now);&#125;int search(int l,int r,int i,int j,int now)&#123;//l,r表示当前区间,i,j表示查询区间 if(i &lt;= l &amp;&amp; j &gt;= r)&#123; return tree[now]; &#125; int cnt = 0,mid = (l + r)/2; if(i &lt;= mid) cnt += search(l,mid,i,j,now &lt;&lt; 1); if(j &gt; mid) cnt += search(mid + 1,r,i,j,(now &lt;&lt; 1)|1); return cnt;&#125;int main()&#123; int t; scanf("%d\n",&amp;t); for(int cnt = 1;cnt &lt;= t; cnt++)&#123; printf("Case %d:\n",cnt); int n; fill(tree,tree + (maxn &lt;&lt; 2), 0); fill(num,num + maxn, 0); scanf("%d",&amp;n); for(int i = 1;i &lt;= n; i++)&#123; scanf("%d",&amp;num[i]); &#125; build_tree(1,n,1); char str[10]; while(scanf("%s",str) != EOF)&#123; if(str[0] == 'E') break; if(str[0] == 'Q')&#123; //cout &lt;&lt; str; int a,b; scanf("%d %d",&amp;a,&amp;b); printf("%d\n",search(1,n,a,b,1)); &#125;else if(str[0] == 'A')&#123; int a,b; scanf("%d %d\n",&amp;a,&amp;b); change(1,n,1,a,b); &#125;else if(str[0] == 'S')&#123; int a,b; scanf("%d %d\n",&amp;a,&amp;b); change(1,n,1,a,0 - b); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(32)】表白记 HRBUST - 1979]]></title>
    <url>%2F2018%2F04%2F06%2F32-%E8%A1%A8%E7%99%BD%E8%AE%B0%20HRBUST%20-%201979%2F</url>
    <content type="text"><![CDATA[表白记 HRBUST - 1979Problem Description 单身的1暗恋上了一个女生，于是想给她告白，于是就在房间里用蛋糕堆了一个心的形状。 可是天公不作美，在这个房间的某个角落里藏着一只小老鼠，小老鼠虎视眈眈的看着这些蛋糕，想等1走之后去偷吃蛋糕。 一个房间可以看成n*n的方格。小老鼠可以往上、下、左、右四个方向走。问小老鼠吃到蛋糕最少需要多少步？ Input 本题有多组测试，每组测试第一行输入三个正整数n，x，y。n代表房间的长宽，(x,y)代表老鼠洞的位置（老鼠出现在老鼠洞这个点也算一步）。接下来n行是房间的布置， ’#’代表蛋糕，’.’代表空地。其中(x,y)一定满足位于房间的边上。(7 ≤n ≤ 99,1 ≤ x,y ≤ n） Output 对于每组测试数据输出一个整数，占一行。 Sample Input 11 1 8………..………..…#…#…..###.###...#########..#########...#######..…#####…….###….…..#…..………..9 7 9………………..##.##...#######..#######...#####..…###…….#….……… Sample Output 34 solution 这道题是标准的广搜题，值得注意的是给出的老鼠方位在数组下标里需要进行减一操作； code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 100char mp[maxn][maxn];int mp1[maxn][maxn];typedef struct node&#123; int x,y,cnt; node(int a,int b,int c)&#123; cnt = a; x = b; y = c; &#125;&#125;creatnode;queue&lt;node&gt; q;int n,x,y,cnt = 0;void add(int cnt,int x,int y)&#123; creatnode p1(cnt + 1,x + 1,y); q.push(p1); creatnode p2(cnt + 1,x - 1,y); q.push(p2); creatnode p3(cnt + 1,x,y + 1); q.push(p3); creatnode p4(cnt + 1,x,y - 1); q.push(p4);&#125;void bfs(int x, int y)&#123; for(int i = 0;i &lt; n; i++) fill(mp1[i],mp1[i] + maxn,0); while(!q.empty())&#123; creatnode p = q.front(); q.pop(); if(p.x &gt;= 0 &amp;&amp; p.x &lt; n &amp;&amp; p.y &gt;= 0 &amp;&amp; p.y &lt; n &amp;&amp; mp1[p.x][p.y] == 0)&#123; cnt = p.cnt; mp1[p.x][p.y] = cnt; if(mp[p.x][p.y] == '#')&#123; break; &#125; else&#123; add(p.cnt,p.x,p.y); &#125; &#125; &#125;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; x &gt;&gt; y)&#123; getchar(); while(!q.empty()) q.pop(); for(int i = 0;i &lt; n; i++)&#123; gets(mp[i]); &#125; creatnode p(1,x - 1,y - 1); q.push(p); bfs(x,y); cout &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(31)】马拉车算法(最长回文子串 HihoCoder - 1032)(最长回文 HDU-3068)]]></title>
    <url>%2F2018%2F04%2F06%2F31-manacher%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最长回文子串 HihoCoder - 1032 Time Limit:1000msCase Time Limit:1000msMemory Limit:64MB Problem Description 小Hi和小Ho是一对好朋友，出生在信息化社会的他们对编程产生了莫大的兴趣，他们约定好互相帮助，在编程的学习道路上一同前进。 这一天，他们遇到了一连串的字符串，于是小Hi就向小Ho提出了那个经典的问题：“小Ho，你能不能分别在这些字符串中找到它们每一个的最长回文子串呢？” 小Ho奇怪的问道：“什么叫做最长回文子串呢？” 小Hi回答道：“一个字符串中连续的一段就是这个字符串的子串，而回文串指的是12421这种从前往后读和从后往前读一模一样的字符串，所以最长回文子串的意思就是这个字符串中最长的身为回文串的子串啦~” 小Ho道：“原来如此！那么我该怎么得到这些字符串呢？我又应该怎么告诉你我所计算出的最长回文子串呢？ 小Hi笑着说道：“这个很容易啦，你只需要写一个程序，先从标准输入读取一个整数N（N&lt;=30)，代表我给你的字符串的个数，然后接下来的就是我要给你的那N个字符串（字符串长度&lt;=10^6)啦。而你要告诉我你的答案的话，只要将你计算出的最长回文子串的长度按照我给你的顺序依次输出到标准输出就可以了！你看这就是一个例子。” Sample Input 3abababaaaaabaaacacdas Sample Output 753 code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;#define maxn 200000000char str[maxn],s[maxn];int main()&#123; int n; scanf("%d",&amp;n); getchar(); while(n--)&#123; scanf("%s",s); int cnt = 0; str[cnt++] = '$';str[cnt++] = '#'; int len1 = strlen(s); for(int i = 0;i &lt; len1; i++)&#123; str[cnt++] = s[i]; str[cnt++] = '#'; &#125; str[cnt] = '\0'; //cout &lt;&lt; str &lt;&lt; endl;// int len = strlen(str); vector&lt;int&gt; p(len + 1,0); int mi = 0,right = 0,maxlen = 0; for(int i = 1;i &lt; len; i++)&#123; p[i] = right &gt; i?min(p[2*mi - i],right - i):1; while(str[i - p[i]] == str[i + p[i]])&#123; p[i]++; &#125; if(i + p[i] &gt; right)&#123; mi = i; right = i + p[i]; &#125; if(p[i] &gt; maxlen)&#123; maxlen = p[i]; &#125; &#125; printf("%d\n",maxlen - 1); &#125; return 0;&#125; 最长回文 hdu-3068 Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 26731 Accepted Submission(s): 9773 Problem Description 给出一个只由小写英文字符a,b,c…y,z组成的字符串S,求S中最长回文串的长度.回文就是正反读都是一样的字符串,如aba, abba等 Input 输入有多组case,不超过120组,每组输入为一行小写英文字符a,b,c…y,z组成的字符串S两组case之间由空行隔开(该空行不用处理)字符串长度len &lt;= 110000 Output 每一行一个整数x,对应一组case,表示该组case的字符串中所包含的最长回文长度. Sample Input aaaa abab Sample Output 43 Source 2009 Multi-University Training Contest 16 - Host by NIT code1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;#define maxn 500000char str[maxn],s[maxn];int main()&#123; while(~scanf("%s",s))&#123; int cnt = 0; str[cnt++] = '$';str[cnt++] = '#'; int len1 = strlen(s); for(int i = 0;i &lt; len1; i++)&#123; str[cnt++] = s[i]; str[cnt++] = '#'; &#125; str[cnt] = '\0'; //cout &lt;&lt; str &lt;&lt; endl;// int len = strlen(str); vector&lt;int&gt; p(len + 1,0); int mi = 0,right = 0,maxlen = 0; for(int i = 1;i &lt; len; i++)&#123; p[i] = right &gt; i?min(p[2*mi - i],right - i):1; while(str[i - p[i]] == str[i + p[i]])&#123; p[i]++; &#125; if(i + p[i] &gt; right)&#123; mi = i; right = i + p[i]; &#125; if(p[i] &gt; maxlen)&#123; maxlen = p[i]; &#125; &#125; printf("%d\n",maxlen - 1); getchar(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(30)】Keywords Search(AC自动机模版题) HDU-2222]]></title>
    <url>%2F2018%2F04%2F06%2F30-AC%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[Keywords Search Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 131072/131072 K (Java/Others)Total Submission(s): 72957 Accepted Submission(s): 24969 Problem Description In the modern time, Search engine came into the life of everybody like Google, Baidu, etc.Wiskey also wants to bring this feature to his image retrieval system.Every image have a long description, when users type some keywords to find the image, the system will match the keywords with description of image and show the image which the most keywords be matched.To simplify the problem, giving you a description of image, and some keywords, you should tell me how many keywords will be match. Input First line will contain one integer means how many cases will follow by.Each case will contain two integers N means the number of keywords and N keywords follow. (N &lt;= 10000)Each keyword will only contains characters ‘a’-‘z’, and the length will be not longer than 50.The last line is the description, and the length will be not longer than 1000000. Output Print how many keywords are contained in the description. Sample Input 15shehesayshrheryasherhs Sample Output 3 solution 这道题是AC自动机的模版题，就是trie+KMP的AC自动机后面我会出一个专题描述AC自动机(有同学可能会问为什么没有29，那是因为我之前想写SUST的校赛题解，但是还没写，先空着吧=-=) code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef struct node &#123; int sum; struct node* next[26]; struct node* fail;&#125;trie;trie *root;int cnt;void init(struct node* temp) &#123; temp-&gt;sum = 0; temp-&gt;fail = NULL; for(int i = 0;i &lt; 26; i++) &#123; temp-&gt;next[i] = NULL; &#125;&#125;void insert(string &amp;str) &#123; int len = str.size(); trie* now = root; for(int i = 0;i &lt; len; i++) &#123; int x = str[i] - 'a'; if(now-&gt;next[x] == NULL) &#123; trie* node = new trie; init(node); &#125; now = now-&gt;next[x]; &#125; now-&gt;sum++;&#125;void buildfail(trie* node) &#123; queue&lt;trie*&gt; q; q.push(node); while(!q.empty()) &#123; node = q.front();q.pop(); for(int i = 0;i &lt; 26; i++)&#123; if(node-&gt;next[i] != NULL)&#123; if(node == root)&#123; node-&gt;next[i]-&gt;fail = root; &#125;else&#123; trie* temp = node-&gt;fail; while(temp != NULL)&#123; if(temp-&gt;next[i] != NULL)&#123; node-&gt;next[i]-&gt;fail = temp-&gt;next[i]; break; &#125; temp = temp-&gt;fail; &#125; if(temp == NULL) node-&gt;next[i]-&gt;fail = root; &#125; q.push(node-&gt;next[i]); &#125; &#125; &#125;&#125;void searchstr(string &amp;str)&#123; trie *node = root; int len = str.size(); for(int i = 0;i &lt; len; i++)&#123; int x = str[i] - 'a'; while(node-&gt;next[x] == NULL &amp;&amp; node != root) node = node-&gt;fail; node = node-&gt;next[x]; if(node == NULL) node = root; trie* temp = node; while(temp != root)&#123; if(temp-&gt;sum &gt;= 0)&#123; cnt += temp-&gt;sum; temp-&gt;sum = -1; &#125;else break; temp = temp-&gt;fail; &#125; &#125;&#125;int main() &#123; int t,n; cin &gt;&gt; t; root = new trie; init(root); getchar(); while(t--) &#123; cin &gt;&gt; n; getchar(); string str; while(n--) &#123; getline(cin,str); insert(str); &#125; getline(cin,str); buildfail(root); searchstr(str); cout &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(29)】SUST第一届ACM校赛题解]]></title>
    <url>%2F2018%2F03%2F14%2F29-xinshengsai%2F</url>
    <content type="text"><![CDATA[这个人很懒，什么都没留下 这是留空来写SUST校赛题解的=-=还没补上]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(28)】高等排序算法(2) 归并排序(MergeSort)]]></title>
    <url>%2F2018%2F03%2F09%2F28-mergesort%2F</url>
    <content type="text"><![CDATA[归并排序介绍 归并排序，是分治法的一个重要应用，主要分为分、合两个阶段。在归并排序中，合非常重要，要将多个数组按照排序合在一起，要运用到多个指针。但是归并排序的代码量并不大，只要运用递归，就可以分为logn层，并且要运用到额外的储存空间。而且归并排序是一种稳定排序。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;using namespace std;void _printf(int *a, int n)&#123; for(int i = 0;i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125;void merge(int *a,int left,int right,int *temp)&#123; if(left &lt; right)&#123; int mid = (left + right)/2; int i = left,j = mid + 1,t = 0; while(i &lt;= mid &amp;&amp; j &lt;= right)&#123; if(a[i] &lt;= a[j])&#123; temp[t] = a[i]; i++; &#125;else&#123; temp[t] = a[j]; j++; &#125; t++; &#125; while(i &lt;= mid)&#123; temp[t] = a[i]; i++;t++; &#125; while(j &lt;= right)&#123; temp[t] = a[j]; j++;t++; &#125; t = 0; while(left &lt;=right)&#123; a[left] = temp[t]; t++;left++; &#125; &#125;&#125;void _sort(int *a,int left,int right,int *temp)&#123; if(left &lt; right)&#123; int mid = (left + right)/2; _sort(a,left,mid,temp); _sort(a,mid + 1,right,temp); merge(a,left,right,temp); &#125;&#125;int main()&#123; int n; while(cin &gt;&gt; n)&#123; clock_t begin,stop; FILE *fp; fp = fopen("1000000000.txt","r"); int *a = new int[n],*temp = new int[n]; for(int i = 0;i &lt; n; i++)&#123; fscanf(fp,"%d",&amp;a[i]); //cin &gt;&gt; a[i]; &#125; cout &lt;&lt; "start" &lt;&lt; endl; begin = clock(); _sort(a,0,n - 1,temp); stop = clock(); //_printf(a,n); cout &lt;&lt; "runtime " &lt;&lt; (double)(stop - begin)/CLOCKS_PER_SEC &lt;&lt; "s" &lt;&lt; endl; &#125; return 0;&#125; 速度 归并排序的平均复杂度为O(nlogn) 数据量 运行时间 5000 0.001s 20000 0.004s 50000 0.012s 100000 0.022s 1000000 0.259s 10000000 2.839s 100000000 30.312s]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(27)】高等排序算法(1) 快速排序(QuickSort)]]></title>
    <url>%2F2018%2F03%2F08%2F27-quicksort%2F</url>
    <content type="text"><![CDATA[快速排序介绍 快速排序是工业上最常用的高等排序算法，最好情况下复杂度为O(nlogn)。但是，在最糟糕的情况下，快排的复杂度可以降为O(n2)，和冒泡排序没啥区别。但是这种情况及其少见。因此，快排的平均复杂度为O(nlogn)。另外，很多公司的面试题对快排情有独钟。所以，快排在ACM有着举足轻重的作用。PS:快排是一种不稳定排序算法。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#include&lt;algorithm&gt;using namespace std;int n;void _printf(int *a,int n)&#123; for(int i = 0;i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125;void _sort(int *a,int left,int right)&#123; if(right &gt; left)&#123; int v = a[left]; int _left = left,_right = right; while(left != right)&#123; while(right &gt; left &amp;&amp; v &lt; a[right])&#123; //cout &lt;&lt; "right " &lt;&lt; right &lt;&lt; endl; right--; &#125; a[left] = a[right]; while(right &gt; left &amp;&amp; a[left] &lt;= v)&#123; //cout &lt;&lt; "left " &lt;&lt; left &lt;&lt; endl; left++; &#125; a[right] = a[left]; &#125; a[left] = v; //_printf(a,n); _sort(a,_left,left - 1); _sort(a,right + 1,_right); &#125;&#125;int main()&#123; //FILE *fp; clock_t begin,stop; //fp = fopen("100000000.txt","r"); while(cin &gt;&gt; n)&#123; int *a = new int[n]; for(int i = 0;i &lt; n; i++)&#123; //fscanf(fp,"%d",&amp;a[i]); cin &gt;&gt; a[i]; &#125; cout &lt;&lt; "start" &lt;&lt; endl; begin = clock(); _sort(a,0,n - 1); stop = clock(); //_printf(a,n); cout &lt;&lt; "runtime " &lt;&lt; (double)(stop - begin)/CLOCKS_PER_SEC &lt;&lt; "s" &lt;&lt; endl; &#125; return 0;&#125; 速度 快排的速度对于一般情况而言，快排的速度特别快，而且不占用多余内存，使用内部排序。 数据量 快速排序所需时间 希尔排序所需时间 插入排序所需时间 选择排序所需时间 5000 0.001s 0.001s 0.031s 0.047s 20000 0.002s 0.006s 0.550s 0.733s 50000 0.007s 0.016s 3.569s 4.624s 100000 0.015s 0.037s 13.799s 17.952s 1000000 0.203s 0.516s —- —- 10000000 6.143s 8.360s —- —- 100000000 501.819s 132.949s —- —-]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(26)】初等排序算法(3) 插入排序 希尔排序 (更正)]]></title>
    <url>%2F2018%2F03%2F07%2F26-shellsort-update%2F</url>
    <content type="text"><![CDATA[前言 此前写的排序算法都是按照中文介绍自己打的代码，今天有幸看一下书，发现插入排序的部分操作上和我想象中不太一样，导致了我的排序算法复杂度变得更复杂。所以，今天再次手打了两个算法，更正了以前的错误。然而发现希尔排序的复杂度较昨天按照自己想法的希尔排序的复杂度有着巨大的优化，对于处理大量数据有着明显优势。所以今天因为无聊，试了一下一百万个数据，发现比自己想象要快得多(毕竟对于我这种弱鸡而言，第一次写那么高级的算法)，处理1百万个数据居然只需要0.516秒。于是我觉得不能满足我的好奇心，便试了一下一千万个数据，这次慢了点，只有8.360秒。但是，你觉得这样就能解决我的好奇心吗？我又试了一亿个数据，但是我没渴望算法有多快，只是单纯想知道要处理多久而已。事实证明需要132.949秒。你以为这样就完了？当然没有，我又试了一下十亿个数据，于是我的打表程序为了这十亿个数据打了5分钟，打出了一个5.39GB的.txt文件。等到我跃跃欲试的时候，却提示我内存不够？！！！ terminate called after throwing an instance of ‘std::bad_alloc’ what(): std::bad_alloc This application has requested the Runtime to terminate it in an unusual way.Please contact the application’s support team for more information. 黑人问号.jpg很感谢我的打表程序，给我打了几十亿个数据，在文章最后会附上打表程序。 插入排序(更正)介绍 介绍之前说过了，就不多说了呢，因为此前的排序算法都是按照理论自己打的，所以今天发现了一个重大错误，严重影响了算法复杂度。错误在于把插入比较交换的关键步骤给复杂化了。直接上代码吧。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;ctime&gt;using namespace std;void _printf(int *a,int n)&#123; for(int i = 0;i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125;void sort(int *a,int n)&#123; for(int i = 1;i &lt; n; i++)&#123;//element before i finished sort for(int j = 0;j &lt; i; j++)&#123; if(a[i] &lt; a[j])&#123; int x = a[i]; for(int y = i;y &gt; j; y--)&#123; a[y] = a[y - 1]; &#125; a[j] = x; break; &#125; &#125; //_printf(a,n); &#125;&#125;int main()&#123; int n; while(cin &gt;&gt; n)&#123; int *a = new int[n]; for(int i = 0;i &lt; n; i++)&#123; cin &gt;&gt; a[i]; &#125; clock_t begin,stop; double runtime; cout &lt;&lt; "Start" &lt;&lt; endl; begin = clock(); sort(a,n); stop = clock(); _printf(a,n); runtime = (double)(stop - begin)/CLOCKS_PER_SEC; cout &lt;&lt; "runtime " &lt;&lt; runtime &lt;&lt; "s" &lt;&lt; endl; &#125; return 0;&#125; 速度 更正错误后，算法复杂度有较大提升 数据量 更正前处理时间 更正后处理时间 5000 0.031s 0.002s 20000 0.550s 0.335s 50000 3.569s 2.123s 100000 13.799s 8.488s 希尔排序(更正)介绍 同上，因为希尔排序是基于插入排序的，所以导致了我昨天写的希尔排序数据处理的非常缓慢。更正后的希尔排序也使用了1，4，13…的增量，使得速度得到了巨大的提升。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;using namespace std;void _printf(int *a,int n)&#123; for(int i = 0;i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125;void _sort(int *a,int n)&#123; int flag = 0,add[30] = &#123;1&#125;; while(add[flag] &lt; n)&#123; add[flag + 1] = 3*add[flag] + 1; flag++; &#125; flag--; //_printf(add,flag); while(flag &gt;= 0)&#123; for(int i = add[flag];i &gt;= 0; i--)&#123; for(int j = i;j &lt; n; j += add[flag])&#123; int v = a[j]; int g = j - add[flag]; while(g &gt;= 0 &amp;&amp; v &lt; a[g])&#123; a[g + add[flag]] = a[g]; g -= add[flag]; &#125; a[g + add[flag]] = v; &#125; //_printf(a,n); &#125; flag--; &#125;&#125;int main()&#123; clock_t begin,stop; int n; while(cin &gt;&gt; n)&#123; //FILE *fp; //fp = fopen("1000000000.txt","r"); int *a = new int[n]; for(int i = 0;i &lt; n; i++)&#123; // fscanf(fp,"%d",&amp;a[i]); cin &gt;&gt; a[i]; &#125; cout &lt;&lt; "loading" &lt;&lt;endl; begin = clock(); _sort(a,n); stop = clock(); cout &lt;&lt; "end" &lt;&lt; endl; //_printf(a,n); cout &lt;&lt; "runtime " &lt;&lt; (double)(stop - begin)/CLOCKS_PER_SEC &lt;&lt; "s" &lt;&lt; endl; &#125; return 0;&#125; 速度 更正后的速度得到了非常大的提升，完全不在一个数量级 数据量 更正前处理时间 更正后处理速度 5000 0.088s 0.001s 20000 1.337s 0.006s 50000 9.289s 0.016s 100000 36.157s 0.037s 1000000 —- 0.516s 10000000 —- 8.360s 100000000 —- 132.949s 处理一百万个数据，更正前的希尔排序要用的时间我是不敢想象 打表程序代码123456789101112131415#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;using namespace std;int main()&#123; FILE *fp; fp = fopen("1000000000.txt","w"); for(int i = 1;i &lt;= 1000000000; i++)&#123; fprintf(fp,"%d ",rand()); if(i%15 == 0) fprintf(fp,"\n"); &#125; return 0;&#125; 举例 5000个数据的打表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950018467 6334 26500 19169 15724 11478 29358 26962 24464 570528145 23281 16827 9961 491 2995 11942 4827 5436 3239114604 3902 153 292 12382 17421 18716 19718 19895 544721726 14771 11538 1869 19912 25667 26299 17035 9894 2870323811 31322 30333 17673 4664 15141 7711 28253 6868 2554727644 32662 32757 20037 12859 8723 9741 27529 778 123163035 22190 1842 288 30106 9040 8942 19264 22648 2744623805 15890 6729 24370 15350 15006 31101 24393 3548 1962912623 24084 19954 18756 11840 4966 7376 13931 26308 1694432439 24626 11323 5537 21538 16118 2082 22929 16541 483331115 4639 29658 22704 9930 13977 2306 31673 22386 502128745 26924 19072 6270 5829 26777 15573 5097 16512 2398613290 9161 18636 22355 24767 23655 15574 4031 12052 273501150 16941 21724 13966 3430 31107 30191 18007 11337 1545712287 27753 10383 14945 8909 32209 9758 24221 18588 642224946 27506 13030 16413 29168 900 32591 18762 1655 174106359 27624 20537 21548 6483 27595 4041 3602 24350 1029130836 9374 11020 4596 24021 27348 23199 19668 24484 82814734 53 1999 26418 27938 6900 3788 18127 467 372814893 24648 22483 17807 2421 14310 6617 22813 9514 143097616 18935 17451 20600 5249 16519 31556 22798 30303 622411008 5844 32609 14989 32702 3195 20485 3093 14343 305231587 29314 9503 7448 25200 13458 6618 20580 19796 1479815281 19589 20798 28009 27157 20472 23622 18538 12292 603824179 18190 29657 7958 6191 19815 22888 19156 11511 162022634 24272 20055 20328 22646 26362 4886 18875 28433 2986920142 23844 1416 21881 31998 10322 18651 10021 5699 355728476 27892 24389 5075 10712 2600 2510 21003 26869 1786114688 13401 9789 15255 16423 5002 10585 24182 10285 2708831426 28617 23757 9832 30932 4169 2154 25721 17189 1997631329 2368 28692 21425 10555 3434 16549 7441 9512 3014518060 21718 3753 16139 12423 16279 25996 16687 12529 2254917437 19866 12949 193 23195 3297 20416 28286 16105 2448816282 12455 25734 18114 11701 31316 20671 5786 12263 431324355 31185 20053 912 10808 1832 20945 4313 27756 2832119558 23646 27982 481 4144 23196 20222 7129 2161 553520450 11173 10466 12044 21659 26292 26439 17253 20024 2615429510 4745 20649 13186 8313 4474 28022 2168 14018 187879905 17958 7391 10202 3625 26477 4414 9314 25824 2933425874 24372 20159 11833 28070 7487 28297 7518 8177 1777332270 1763 2668 17192 13985 3102 8480 29213 7627 48024099 30527 2625 1543 1924 11023 29972 13061 14181 3100327432 17505 27593 22725 13031 8492 142 17222 31286 130647900 19187 8360 22413 30974 14270 29170 235 30833 1971125760 18896 4667 7285 12550 140 13694 2695 21624 280192125 26576 21694 22658 26302 17371 22466 4678 22593 2385125484 1018 28464 21119 23152 2800 18087 31060 1926 90104757 32170 20315 9576 30227 12043 22758 7164 5109 788217086 29565 3487 29577 14474 2625 25627 5629 31928 2542328520 6902 14962 123 24596 3737 13261 10195 32525 12648260 6202 8116 5030 20326 29011 30771 6411 25547 2115321520 29790 14924 30188 21763 4940 20851 18662 13829 3090017713 18958 17578 8365 13007 11477 1200 26058 6439 230312760 19357 2324 6477 5108 21113 14887 19801 22850 1446022428 12993 27384 19405 6540 31111 28704 12835 32356 607229350 18823 14485 20556 23216 1626 9357 8526 13357 2933723271 23869 29361 12896 13022 29617 10112 12717 18696 1158524041 24423 24129 24229 4565 6559 8932 22296 29855 1205316962 3584 29734 6654 16972 21457 14369 22532 2963 26072483 911 11635 10067 22848 4675 12938 2223 22142 237546511 22741 20175 21459 17825 3221 17870 1626 31934 1520531783 23850 17398 22279 22701 12193 12734 1637 26534 55561993 10176 25705 6962 10548 15881 300 14413 16641 1985524855 13142 11462 27611 30877 20424 32678 1752 18443 2829612673 10040 9313 875 20072 12818 610 1017 14932 2811230695 13169 23831 20040 26488 28685 19090 19497 2589 2599015145 19353 19314 18651 26740 22044 11258 335 8759 111927605 25264 12181 28503 3829 23775 20608 29292 5997 1754929556 25561 31627 6467 29541 26129 31240 27813 29174 206016077 20215 8683 8213 23992 25824 5601 23392 15759 267026428 28027 4084 10075 18786 15498 24970 6287 23847 32604503 21221 22663 5706 2363 9010 22171 27489 18240 1216425542 7619 20913 7591 6704 31818 9232 750 25205 49751539 303 11422 21098 11247 13584 13648 2971 17864 2291311075 21545 28712 17546 18678 1769 15262 8519 13985 2828915944 2865 18540 23245 25508 28318 27870 9601 28323 2113224472 27152 25087 28570 29763 29901 17103 14423 3527 1160026969 14015 5565 28 21543 25347 2088 2943 12637 2240926463 5049 4681 1588 11342 608 32060 21221 1758 2995420888 14146 690 7949 12843 21430 25620 748 27067 453620783 18035 32226 15185 7038 9853 25629 11224 15748 199233359 32257 24766 4944 14955 23318 32726 25411 21025 2035531001 22549 9496 18584 9515 17964 23342 8075 17913 1614231196 21948 25072 20426 14606 26173 24429 32404 6705 2062629812 19375 30093 16565 16036 14736 29141 30814 5994 82566652 23936 30838 20482 1355 21015 1131 18230 17841 146252011 32637 4186 19690 1650 5662 21634 10893 10353 2141613452 14008 7262 22233 5454 16303 16634 26303 14256 14811124 12317 4213 27109 24028 29200 21080 21318 16858 2405024155 31361 15264 11903 3676 29643 26909 14902 3561 2848924948 1282 13653 30674 2220 5402 6923 3831 19369 387820259 19008 22619 23971 30003 21945 9781 26504 12392 3268525313 6698 5589 12722 5938 19037 6410 31461 6234 125089961 3959 6493 1515 25269 24937 28869 58 14700 1397126264 15117 16215 24555 7815 18330 3039 30212 29288 280821954 16085 20710 24484 24774 8380 29815 25951 6541 181151679 17110 25898 23073 788 23977 18132 29956 28689 2611310008 12941 15790 1723 21363 28 25184 24778 7200 50711885 21974 1071 11333 22867 26153 14295 32168 20825 967615629 28650 2598 3309 4693 4686 30080 10116 12249 266671528 26679 7864 29421 8405 8826 6816 7516 27726 2866629087 27681 19964 1340 5686 6021 11662 14721 6064 2930920415 17902 29873 17124 23941 32745 31762 28423 27531 480612268 9318 5602 31907 24307 23481 1012 21136 26630 2411426809 4084 23556 12290 21293 29996 29152 1054 25345 14708248 7491 13712 5131 30114 16439 7958 24722 29704 69951052 25269 7479 18238 26423 27918 10866 17659 32498 2848621196 7462 26633 12158 12022 1146 18392 13037 3925 1064729458 6602 30807 4098 27830 29292 14600 7278 20799 1835220448 13882 540 28315 4575 8762 9567 22336 18397 3141819897 25828 13851 26816 24230 4449 16925 658 229 2452010940 29560 15147 25162 1655 20675 792 22361 31754 1639823146 8714 26946 21188 19569 8638 27663 15075 24515 11521475 15615 20528 13234 12570 905 9464 19557 28962 1416130524 12549 17469 330 31923 28350 14333 22925 10910 1973716336 18337 1278 12393 7636 30714 28164 31591 19949 191352505 13337 10004 16337 2623 28664 9970 25608 30568 192817085 9152 18373 28652 8194 9876 23826 28396 7572 624914640 29174 18819 943 32611 1941 20289 8419 5565 38057585 16216 31450 1615 2609 11064 9166 16893 16074 1350930300 19695 9573 15589 13161 31172 17968 27358 26031 2626819426 28510 10422 30774 8779 30910 23552 4182 25391 154955764 874 1364 14902 28255 4460 474 6972 26821 2612225547 21577 9789 25605 30195 27594 7950 16343 754 24811012 11672 23439 13428 5912 9762 5967 24408 4415 190817223 11759 26434 5204 29486 4319 958 5945 26806 816618700 11367 17692 21787 28532 30556 30974 3447 5021 1828326222 29331 2376 28583 26948 12723 17982 22018 14776 922031111 32182 23856 19490 8925 4324 6486 19677 15969 116437534 15677 22668 31068 21991 32196 7783 16828 7727 2942615871 10697 17612 18703 11027 11408 5545 9508 7185 3023824237 26443 21313 22501 8850 25128 2111 23650 28149 111921454 15869 681 27465 20267 17713 19793 18634 25472 2097222830 24901 28442 5177 13877 25770 702 14364 1381 165908823 2237 8023 32179 16595 20169 2327 12042 31310 2818211058 7926 9487 1670 32528 5651 2258 7213 9860 2578321286 2742 8610 4472 7128 18434 5841 20718 3503 1486724865 10938 1881 9257 22750 28614 18598 28458 2661 2606332756 20807 20278 19489 19435 6365 32075 7586 1386 78338360 13330 26048 8928 29492 12433 23840 6766 1735 1981011599 11837 21892 31982 7328 29352 11369 31244 21794 66089252 11647 17432 9535 7208 3264 3497 23243 27649 2201526841 189 16100 19812 30648 9523 19851 24474 28633 2989127200 19854 9990 25697 4919 17780 22578 12931 32544 334013487 899 22525 8483 5538 7492 6193 28252 25011 156015834 1840 31497 2785 18529 31540 18805 28791 13392 1321013549 21578 26979 30971 9277 73 20193 1620 21497 1382631276 19790 6582 13578 11159 20418 26489 159 3449 129249072 10380 27008 27967 10208 6477 18503 15370 32607 1419612074 13722 12611 19019 28761 11056 12890 31163 16683 1371619932 25452 2741 4954 6813 2862 10396 15460 20615 109042599 20136 4680 9198 27032 14387 32584 7240 3517 170068670 241 18882 25249 3523 31758 12105 29621 17095 72969916 15678 10178 13579 25058 27577 12750 14007 23729 240812995 2678 24676 27753 20899 11784 15565 3093 13608 617211243 29929 7514 10168 5055 11191 5973 8922 6748 565110986 2144 16446 31577 26517 14629 29916 5874 15791 1546922912 8146 30693 9091 9815 26949 26857 20640 26052 2368551 9487 31226 28162 16955 23183 8394 30180 16097 306527065 2513 9261 12578 21078 16878 14140 4611 31947 2445170 29975 13489 24750 6149 3333 13865 22214 17282 2700727432 8896 16367 28522 4882 31810 17641 7231 2187 67056479 6321 6538 31351 19447 24208 9646 22276 25759 3018930422 27666 8486 3455 2028 29614 4860 29253 11777 3134812503 10861 22431 29082 12455 14197 22106 8752 15821 1729626281 26021 24455 15947 27124 18318 9135 11376 1774 2985924998 12074 9253 6922 10635 1643 28888 8153 13232 474728680 19926 25678 6450 14801 24961 14199 20855 26363 571610573 31561 23245 6473 28274 1550 24353 1181 4287 269918110 18643 17465 7172 2529 9981 2112 13476 4381 824726890 16671 8805 32372 30032 3989 9320 23165 15431 965811293 17206 26578 16948 2206 27171 18166 3396 16697 3102023694 15529 14788 30109 17984 11969 28978 21617 4015 166263684 9168 17906 25928 12097 28118 24390 15199 11785 1448619199 12420 20710 18271 15813 27415 6085 318 3580 13317267 8387 13444 23186 14507 4360 17827 28074 26431 715230271 10268 4693 19885 337 31311 17604 12677 406 776829022 19413 5000 542 17537 30038 21388 7355 13289 316473181 13093 16584 10987 10761 20493 8217 9501 17482 2944715665 10753 22104 15084 19095 13525 30221 3964 21781 48728106 3656 3343 22593 27080 16080 14868 21411 13713 209683251 27216 12079 28768 17040 31531 12933 23779 20663 1225926653 27936 2095 24365 11874 7720 26835 25680 8976 184555725 4071 24808 13559 9156 5602 17832 7905 10440 737521562 22885 21962 21080 1836 10797 31202 10508 10080 534012076 9058 31493 7740 8546 20474 24773 19097 8880 2333511072 23400 707 22955 20666 4141 23588 12481 17168 2831519396 16225 1009 22012 18136 11455 18762 25043 742 2117922 24512 9248 26018 27368 23717 9714 17650 13290 333512759 3169 21895 5303 22640 21979 24199 29105 24791 186618681 3652 8753 24033 32029 15987 7042 26253 20083 1142015814 32718 12244 31063 7229 20652 18864 4769 30470 1500521047 1594 21487 24326 3276 21323 6540 7679 23990 3258824710 29271 17945 29221 28470 20183 23589 23955 4978 247795006 13262 20135 23487 27196 29033 2088 12935 19779 1599314790 24962 18965 11001 19105 11807 24567 2669 3134 326711457 12998 3545 13597 14218 8838 14844 7372 8563 2102829264 28801 14723 13490 7604 31601 24227 11197 23692 1977120363 29301 22363 7721 3565 17421 23445 18610 495 1674115022 31812 29151 23015 8055 3393 8738 15279 19882 160812654 3822 32707 24245 1338 144 22290 31339 23154 246044623 22225 20078 21724 31981 2330 29733 28223 20594 2913018846 4987 29445 18805 8616 5750 20489 27338 21963 2813514697 32209 21630 23224 1908 26737 24474 31920 27372 102933855 6734 9561 31056 27606 8184 7075 28382 14119 674130432 24684 12779 12279 18283 20667 30836 24125 24118 1273718028 32119 20577 10737 14091 20556 22795 16060 21901 87933432 2136 4580 14875 5907 21184 28074 8719 26790 2047630041 3351 8329 16290 22974 23072 3591 12189 15787 314903239 14893 3053 17063 10681 25903 27005 24176 18479 16956139 32468 13998 21083 23639 29515 27621 29993 15826 1572223838 24828 12581 24399 8978 11891 1023 26943 24834 142437349 2702 8707 20502 25141 10687 8346 15891 24637 1841311400 22816 31690 13162 8935 29126 19410 19877 11382 2626027189 26705 13874 2663 20722 32195 22566 16360 6038 185887811 28245 9467 32425 26867 13189 10542 13063 21547 3050229617 9099 25023 17226 31203 30048 21051 1570 8636 945825967 8456 9405 11531 29962 26819 7975 10556 7531 314958044 30591 26803 3388 18915 7450 12319 6272 25791 2938310133 1775 24642 23569 18300 17954 12078 3585 2257 25333893 10490 10103 4750 17233 10722 24271 19611 18990 3033821641 23258 19047 2352 9658 479 25302 32683 18990 1000215568 4422 16895 6135 18008 12361 16742 22194 23699 2318820178 4042 31357 23941 1847 7469 16345 4380 31913 1496425710 20061 25385 20073 27504 9462 32703 28102 11069 51543529 31552 32074 19149 3730 2244 10844 13049 14118 2406526363 19552 28773 18470 29731 6747 7511 5869 14398 104987103 27352 25679 28053 13043 14522 31088 1563 25834 985017022 7240 21911 9492 5651 28580 15477 27616 29876 191785220 14615 22348 26798 32179 31635 16857 2883 1662 1890228262 19420 19770 19022 9273 25841 12686 28888 3917 317171892 13698 11267 11749 65 10389 6932 25619 16081 200329130 13028 18631 14589 23152 18630 19172 19864 6407 1229525428 29681 18490 26610 26177 31071 25236 6459 20643 1684027633 27037 23893 22630 20274 12993 28782 32203 17461 829019662 22307 20997 31151 18423 8890 16717 6640 28703 55664883 23661 22659 18245 20386 32651 32765 19601 16840 172091497 27283 29250 18058 8421 175 30581 26787 3271 428727999 12504 24979 2138 10700 530 2461 12118 205 754018828 24459 11622 14398 3760 27098 12935 10481 30614 1956718493 28596 19161 7746 10538 7670 20538 21476 21555 2491716371 16760 5752 13758 15433 32255 29065 726 2401 303412759 10393 30548 27273 18792 16193 12933 30137 17103 369028211 13694 24668 32627 7498 989 15248 3879 11647 1114930931 669 30875 25598 25449 25436 24599 20123 1443 173118154 22861 4434 9385 23967 10816 11393 16704 29866 3095330308 28223 18684 30792 22667 10048 32469 13930 30811 1981416090 5427 23743 1604 10599 16474 7195 506 5158 175899858 27809 17889 11447 40 3818 9364 17975 26 250892503 30066 26412 6840 12570 14676 25395 28641 29986 1765121109 8187 20083 21085 23390 31250 18686 4755 11381 2812825502 24277 30862 26424 3565 3872 832 30885 14428 664620889 6478 10883 24925 21265 31260 5045 20778 5821 138552520 12927 24773 25134 27251 22675 13336 16334 21001 27379310 5974 7590 20356 1071 32080 10935 32145 17282 182518718 13573 4712 13037 4998 9905 7162 1717 8692 1953928047 10946 19103 30231 24115 839 25858 20829 2645 339417199 19645 14272 675 21862 32072 13773 2480 11238 268973542 29608 19203 23277 6125 20134 1401 9078 18382 2016920736 27478 17939 21138 18721 31426 10663 1677 21575 672425981 27700 7961 28862 16002 18448 25095 684 24016 151379507 13993 21284 2944 30259 821 7058 24643 17668 10677119 29857 23041 8891 25264 1623 6915 8072 17929 8414715 17615 12536 14957 27759 700 13452 5093 24241 1182912448 5227 11798 16224 10324 12274 18133 22885 15038 121706862 32629 5084 11909 14878 6923 27085 29400 23024 1419323105 9412 15765 5767 15407 10677 13784 704 14790 983410891 621 18085 27734 25190 20542 17998 22086 32018 1562130424 22597 21376 24254 29669 18108 12927 12493 26068 63669102 2438 12600 10819 14318 2290 14984 16339 2556 258084632 21478 26814 13787 7239 28074 25020 10827 2554 19887441 16798 13642 19002 16321 30104 13946 7056 18509 2983317708 19761 6533 20686 14804 26385 10142 18842 17260 2216131620 4343 9578 1187 113 13063 4591 5934 20415 65629761 25012 28411 11959 16251 18738 13370 26124 5507 800717584 10951 23101 14489 24958 15441 1790 17013 30412 1485521060 7093 8472 25402 32676 13543 7373 6266 27651 1527521528 532 10761 5469 32503 32729 17107 27892 2451 1795328392 22570 13519 19472 23407 22494 9505 28440 20383 1426221409 28607 18038 4360 5471 11171 20654 29947 11514 1452321229 489 6766 17887 29756 26632 7470 25739 20666 85227283 8160 17553 24705 27091 1259 25386 31687 4629 4228317 22045 12356 13388 25452 3154 30466 11833 27760 2691925631 6738 21267 25776 21098 24314 16320 13053 24007 1646924216 9722 19842 29007 15463 26260 30947 13793 28630 1871723043 31376 25314 16626 17117 1334 20620 14171 26792 896419154 18866 14693 30664 23775 13000 12212 21100 7551 254766379 10943 17877 3789 361 11385 8272 11434 15144 2956125563 14504 12946 23888 20308 12157 1430 5123 6464 40744346 13837 1981 25318 26611 16292 17591 3832 27123 646116991 31461 27330 28498 17369 17291 8400 14179 24117 231719914 1595 1441 5936 21867 7028 31453 27909 13973 1798111503 26569 6816 1883 25367 5385 28402 5230 17157 2868115567 8310 1866 3687 13171 3477 31245 32764 6238 276712047 26115 4592 27311 32657 1405 53 7171 20580 2274022530 13675 24320 25790 13377 10998 16586 21604 4489 1963129744 8388 26610 18718 26919 18259 5927 14609 28119 2147922716 6300 21396 16853 11458 20830 24593 30806 29849 1485424272 26160 12294 12054 26333 146 4229 10471 10428 1055922241 29421 22688 16366 12033 26685 2270 25329 32261 228602208 8982 22162 32506 6878 11979 1897 7887 6538 1446930783 17540 22795 7266 18633 13509 24557 2317 26134 3205318135 12258 2593 17843 21693 16466 22951 18140 11094 129375174 2512 6097 9551 2695 21817 23492 21292 20237 27530613 25296 21710 32389 5628 5809 28786 31744 18840 818228569 6120 27393 6292 14962 14214 12527 26807 13194 870514713 7011 18913 6693 19664 26203 28995 17762 14381 2694629909 1048 21768 26624 22511 7954 4235 1127 14633 282401862 15127 27577 23817 2340 10142 15100 28400 6558 214763154 10935 16430 5831 21295 3537 15623 17922 2927 2802930211 16211 11754 26880 12253 3293 21321 20785 26528 1044331000 10555 24671 9270 7452 9375 14631 13640 8934 180407986 28834 14248 1539 28765 12796 10312 7262 25052 3073123987 24464 32557 14248 29556 20170 5450 27182 7301 1329324099 23332 19044 32331 75 31004 19050 15026 14066 1173819801 19623 13843 441 3380 19695 7918 3659 1363 126286329 1088 28854 8613 24979 18569 666 7679 27577 278373402 23115 23292 1723 2872 29448 30323 11153 15948 2439525197 4508 22908 17411 13993 7665 26781 3202 17610 2482827256 27705 8965 18023 20769 11715 20253 31805 23684 2947832145 21840 833 19285 26900 10968 23994 16633 13885 34818281 18032 16256 29910 10872 8982 23901 12306 10635 1786032471 29527 7137 8343 9768 28233 3995 29171 7603 2894218011 7879 31034 14512 24593 530 14161 23234 10258 219265906 5191 14443 6188 30227 32719 26484 5224 19093 3043513224 28094 3582 8867 8627 22005 11146 32686 16589 2054018237 22850 18759 9578 28956 32677 2403 28042 6300 158115225 21143 21595 21016 26615 28804 21006 28368 31641 30335698 1325 28313 28023 22312 24618 18457 18396 8339 2108632094 7846 27043 31522 12911 16280 23455 26358 26847 28870990 3873 4327 3413 3454 31896 12472 24450 17241 46415646 23525 28213 16824 17929 8695 25403 12594 7993 2606722187 4640 25079 10041 18125 12534 4860 23000 4907 3262127692 25293 5117 7717 20403 3943 17893 10639 29011 2692524028 19978 10748 2850 22892 26444 10654 23623 24353 1203631547 21346 826 16061 3904 10238 17571 26886 16405 529922056 11728 1267 3751 2019 19991 18166 5717 25846 170933187 1421 22912 6867 28299 32444 29897 1201 3328 249427104 1768 29768 26641 16296 11262 10720 21244 27918 962521219 17584 18174 10984 10459 13149 17014 5695 12503 503213851 1537 26814 8363 4651 1219 24290 25917 21683 3191826584 27252 3586 31269 26248 12137 2397 424 23168 2002728148 31993 10382 29271 27669 893 20877 1014 19104 4842943 11495 26811 1293 28892 6798 1990 11299 14890 849329074 1549 13774 9314 20173 24069 29218 26865 16833 1523819911 13252 6463 6508 25149 23088 12245 6231 31920 1010619271 12368 6421 15258 4157 9647 4982 18238 24122 17723906 18706 10189 11156 30345 12351 6923 7118 31550 209711836 10591 13406 4510 25813 14651 25880 27844 24743 774111245 14578 4949 21705 24514 19785 9227 8624 17204 2835623917 6227 555 10102 14286 19468 11698 8979 21411 1248910758 13490 30775 28410 17132 27089 27296 11950 23112 2012212529 7672 25836 18277 5553 13976 10670 9085 32652 175130397 19751 29001 435 16693 15072 17916 6716 25328 151132125 11838 27296 18939 11544 1056 12826 12902 26758 2458812021 22586 14108 29777 12628 21979 26947 12549 1280 1324525128 14062 10426 4719 10677 29091 4047 13785 23231 74068684 21954 16769 14709 27956 22421 15945 13465 16016 2186016497 18335 5190 5677 28049 21005 7886 23388 18675 1314317377 10130 28487 26555 22482 25253 15000 27754 289 3248825215 12008 31310 940 27799 2997 9707 8454 304 823710485 12499 30792 29613 32612 18682 12983 15351 16129 171375033 16600 31864 23683 11857 8968 1710 21968 31708 264127732 12437 11684 32499 32701 29869 28583 29256 19692 764012087 15012 13810 5820 14835 1663 10615 25897 18677 277410134 27553 19533 28878 2286 25624 2734 18075 15349 3071226984 30624 27792 6504 28822 4055 18913 462 24473 2008424160 31122 26053 19397 11822 19750 21337 13917 4006 493122197 27505 29236 10357 6599 28290 1898 985 21447 1084592 18725 8996 29855 24828 15338 17342 14428 29795 3074230037 5506 6767 5053 9793 28505 24146 3609 13924 1985429465 12239 26206 24209 15492 16499 18175 31036 23061 1364715618 25013 26727 15712 27896 21909 27841 20130 9090 90347915 6286 3523 20666 1344 32736 22037 5416 5893 194930971 10844 22777 19285 26200 14590 10285 28325 17118 2566810006 9729 24008 14541 225 15536 11980 716 30470 1538428747 20328 27936 6204 10700 7523 26364 1411 16040 25011504 23483 21766 16141 2670 10845 10506 9088 23256 251078266 5857 22678 14199 12674 14155 25191 8990 29832 3085810996 8917 28290 3967 1707 8234 28246 11462 19402 82393426 19095 30906 8314 10350 4586 5279 17776 25822 687932301 15812 5676 3164 7357 32570 6038 24312 10144 1656128180 18200 30643 21856 18061 2647 5939 19808 9290 17452979 32618 21419 24007 22284 24547 29977 15675 18613 1870913371 28642 16339 6336 32621 21501 26034 18129 21358 143628469 22897 28504 4798 4202 23105 1238 15032 20065 1251614481 15579 9023 1727 1771 31313 10382 6140 24816 2848815319 5589 5513 18259 20851 32271 23283 4364 27038 30123184 21759 23501 9574 28733 5059 27714 27649 6595 2852224541 20416 15377 1052 565 19891 138 13310 20967 1505513787 27224 18222 16439 27441 6648 26804 27834 19368 314418872 32668 19974 19176 5137 20633 3241 5745 18018 3101522974 19252 846 8956 25524 6966 15581 8144 32240 2933415296 11876 25027 1205 2018 4291 31641 13465 16191 224716259 23700 20217 2016 1943 14624 17064 31505 1157 315027666 9275 32046 17632 29789 6046 2145 6003 13152 319018326 29153 21184 19649 30350 10405 24346 1025 28970 143364795 9793 11323 5532 28856 15896 3210 17776 5692 1455015290 13795 13852 17350 8315 10036 29361 3760 9984 87292534 6050 28082 16806 1936 25584 10790 21617 29182 1906623116 6388 9425 13101 5610 6450 19982 28621 5193 2703816754 4593 14895 20280 5638 25167 17420 4345 16883 2386524696 30833 10390 22632 20189 17839 20183 13817 22129 675310679 18613 10600 8252 15145 19861 2151 28318 28963 781314907 29554 31476 617 11211 25429 2264 15966 19531 2994210698 19522 31155 27587 15257 23158 4464 13762 8510 3094631065 8380 13165 5946 13540 27297 8042 14464 23194 1258410270 32715 32200 1206 32106 31302 24696 8833 7611 19067415 6645 30175 6354 23448 24919 13079 27988 26321 759231597 22197 13509 8652 71 658 14122 26859 7997 109991899 4120 1320 32036 16984 4912 1915 23953 19485 2074110199 11567 4208 6844 30169 29681 4879 21108 17207 525925706 23849 24075 28026 20124 27607 17774 2884 20128 245463145 20481 11714 20149 24168 13338 20307 26793 23504 11051697 18217 15955 16641 2343 26133 32097 679 20736 1955525633 1954 930 10252 19904 20279 12488 24870 31754 2607232176 26701 15415 18086 4231 17480 19975 30260 20514 893816657 14990 19438 28981 15447 5242 24618 16070 25631 2406127219 28781 20990 12833 8672 1563 21302 502 26928 3072124898 31447 10945 28406 2222 8686 5794 23577 12844 1868321547 13240 485 16464 31723 20337 16653 27168 28130 152551466 4858 22512 29656 3318 13201 142 21276 31506 3270210684 15023 30270 26312 8250 13475 20311 26850 19195 548811520 26101 20183 24798 27892 18848 6784 30245 12187 1446228343 18258 16859 8871 14016 8172 22832 24441 17683 1608822015 13976 18516 18298 39 31283 3205 19997 29146 576923675 917 9387 15020 6030 17442 21735 32389 20373 348012073 10777 786 8381 31785 522 18345 20979 16085 1571330935 19735 30883 2186 16096 20648 2085 14752 521 926021982 6636 7688 19919 17236 26792 27065 19278 4198 3149626386 21011 10976 7547 12121 23202 7245 6702 28564 315392572 2257 2370 21920 31654 19359 11080 7298 23391 2396030510 29591 25867 22033 1675 12136 30499 17775 25790 1437631256 20272 20703 5086 20967 9515 23542 23495 3566 1845614186 8437 19198 12626 18364 1085 31665 18908 20340 13602814 21154 18012 19752 3338 8706 12525 30630 29249 231793079 8313 28838 32517 8421 14145 5991 1969 21839 2430816565 23762 19473 23681 21970 23147 27053 22708 6508 167154429 31066 27689 14663 11771 5541 16259 18631 23572 251410966 25988 18170 28168 22199 655 3850 13444 12936 1627819406 29427 10313 7523 32371 23327 17073 23461 2173 993431102 25587 31417 31463 6153 26126 20595 1495 29213 240627370 23859 23305 22496 24833 24223 4852 17879 30519 61267793 31585 21465 31371 15444 17107 17271 24087 28099 165198596 5715 17552 22492 14753 8257 27590 24959 13357 108867809 5865 25686 32019 259 22313 2435 1028 4101 1046822869 456 6731 7578 26074 11395 30843 31274 13316 1502430511 18585 5722 8971 10057 14095 8174 5038 2183 2665817295 25722 16983 6231 29503 2232 24300 15590 21480 1740815505 32702 22858 9818 10557 15561 24120 5028 23656 257133332 23092 17182 26467 11320 7358 21074 3987 9094 498321364 27264 19714 26746 24390 10425 26255 13163 31467 579214231 22619 2880 4718 16128 19948 4720 9079 32091 376627587 5808 12126 14825 31159 17518 3220 10035 31314 2545624147 29156 30134 3360 751 16208 31478 22294 12589 175247976 9694 4090 20189 29372 7419 30301 21702 24844 2052326539 20609 11827 6637 8186 27416 1827 15169 17623 1489922514 10415 3644 5436 23669 10378 31676 17858 7952 984627137 5915 22988 24616 7288 2382 28074 20333 3915 1105625656 30062 9616 24524 12129 27442 1984 4872 7049 2339618026 8582 10202 18775 5416 30665 14552 18759 12755 1141722844 3554 19443 6824 31999 28422 121 15733 31413 1991715793 21873 12060 31175 9074 5985 32501 31622 13208 2739511026 26720 26291 31988 10929 9072 30977 10193 8 12254922 30876 15137 30816 13803 21090 7912 12289 17253 299797299 12322 22902 27602 6369 30654 12729 9734 12438 122745226 16463 28134 22972 24348 16453 9503 2307 25518 1833327437 20695 13179 661 23144 17659 10961 21907 6576 1347220645 3592 22972 628 24196 6811 15535 15835 1229 371623532 24956 16158 29749 24620 23296 19724 13120 24526 164068983 3445 30574 21691 26588 30538 20664 18104 20877 203532942 17004 30623 14852 15625 17611 27842 8724 31149 2013513590 10146 7328 23855 27804 31741 16909 19381 12779 2910210083 692 10532 17312 26099 6161 11047 22405 15290 1756929959 32628 22139 21228 27580 32471 21778 27440 18456 2214829444 24745 16125 7210 4698 25616 31180 24815 6064 1622629472 27479 19593 32482 3005 18536 15333 11105 27587 3073215638 31165 1064 14518 8399 5032 17508 13896 13438 2397822638 8245 4059 24169 744 27362 24769 11049 26518 1646710558 32143 23061 25603 9190 22186 1226 3603 17004 2130031768 423 31347 5396 4566 25230 21665 26152 32000 361729173 30786 10668 31597 31579 26224 17728 26260 12158 2342523267 19312 734 452 5169 29562 1570 8211 29235 68901711 2064 4750 28960 7545 14767 21754 30787 8217 2456529942 2088 10273 2815 27579 30837 9388 19269 11886 1383010809 4640 7321 18319 29881 31626 13020 1411 20454 2589321984 2357 22999 30336 18829 5950 21457 32405 10365 233430049 19094 28592 31270 30119 23017 29313 15253 16117 497719160 21505 153 24591 6562 3576 4854 20072 11134 2301625050 9193 21945 1852 20747 32521 8061 6344 20259 283662885 14439 2718 9107 5268 3554 32050 7432 13799 3202016735 31098 2792 3916 26182 19029 25316 3059 13758 458322399 1135 8357 20070 15271 22342 17780 13877 30406 2829517686 2403 8252 15718 23035 7285 28428 16678 25960 10120949 2364 26385 27626 17157 2737 4841 18938 11593 1709631033 4493 29768 27873 29935 19109 30096 20381 21561 257395584 25923 28499 16731 11849 25442 8606 6850 28287 2604022769 9223 1588 16467 12083 3400 11158 15606 16938 1946320920 18366 15758 19685 9023 20229 19298 29356 5470 2317524196 1683 9988 7619 2946 32190 8275 2469 25519 41]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(25)】初等排序算法(2) 希尔排序(shell sort)]]></title>
    <url>%2F2018%2F03%2F06%2F25-shellsort%2F</url>
    <content type="text"><![CDATA[希尔排序介绍 希尔排序是插入排序的延伸，是第一批冲破O(n2)的算法之一。希尔排序在一定意义上有分治的影子，拆分成n组不同的增量的分组，进行插入排序。 有相关证明表示，当增量为1,4,13……时，平均复杂度会降至O(n1.25)。即 a(n + 1) = 3 * a(n) + 1; 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;ctime&gt;using namespace std;void _printf(int *a,int n)&#123; for(int i = 0;i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125;void sort(int *a,int n)&#123; int flag = 0,add[30] = &#123;1&#125;; while(add[flag] &lt; n)&#123; add[flag + 1] = 3*add[flag] + 1; flag++; &#125; flag--; //_printf(add,flag); while(flag &gt;= 0)&#123; for(int i = add[flag];i &gt;= 0; i--)&#123; for(int j = i + add[flag];j &lt; n; j += add[flag])&#123; for(int t = i;t &lt; j; t += add[flag])&#123; if(a[j] &lt; a[t])&#123; int x = a[j]; for(int y = j;y &gt; t; y -= add[flag])&#123; a[y] = a[y - add[flag]]; &#125; a[t] = x; &#125; &#125; &#125; &#125; flag--; &#125;&#125;int main()&#123; clock_t begin,stop; int n; while(cin &gt;&gt; n)&#123; int *a = new int[n]; for(int i = 0;i &lt; n; i++)&#123; cin &gt;&gt; a[i]; &#125; begin = clock(); sort(a,n); stop = clock(); _printf(a,n); cout &lt;&lt; "runtime " &lt;&lt; (double)(stop - begin)/CLOCKS_PER_SEC &lt;&lt; "s" &lt;&lt; endl; &#125; return 0;&#125; 速度 希尔排序的复杂度理论上比插入排序以及选择排序更低，但是。。。无解 数据量 运行时间 5000 0.088s 20000 1.337s 50000 9.289s 100000 36.157s]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(24)】初等排序算法(1) 冒泡 选择 插入]]></title>
    <url>%2F2018%2F03%2F05%2F24-chudeng%20sort%2F</url>
    <content type="text"><![CDATA[前言 因为本人原因，很长时间没有写过每日一题了，很抱歉。接下来会有时候穿插入算法的代码片段，今天写的是初等排序算法一直知道这些排序方法，却没有机会写一遍。所以刚开学，有点时间可以写下基础代码，于是便写了排序。今天写了两个初等排序，本来想写多点的但是。。。你懂的=-= 冒泡排序 因为冒泡排序经常可以用到，也是最慢的排序算法，过程也比较简单，在此不在多写，希望以后可以用多点其他高效的排序算法。 选择排序介绍 所谓选择排序，就是将最小的一个选出来，排在最前(与该位置元素交换)，以此类推。显然，选择排序是一种不稳定的排序。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;ctime&gt;using namespace std;void _printf(int *a,int n)&#123; for(int i = 0;i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125;void sort(int *a,int n)&#123; for(int i = 0;i &lt; n;i++)&#123; int x = i,min = a[i]; for(int j = i;j &lt; n; j++)&#123; if(a[j] &lt; min)&#123; min = a[j]; x = j; &#125; &#125; int t = a[i]; a[i] = min; a[x] = t; &#125;&#125;int main()&#123; int n; clock_t begin,stop; double runtime; while(cin &gt;&gt; n)&#123; int *a = new int[n]; for(int i = 0;i &lt; n; i++)&#123; cin &gt;&gt; a[i]; &#125; cout &lt;&lt; "Start" &lt;&lt; endl; begin = clock(); sort(a,n); stop = clock(); _printf(a,n); runtime = (double)(stop - begin)/CLOCKS_PER_SEC; cout &lt;&lt; "runtime " &lt;&lt; runtime &lt;&lt; "s" &lt;&lt; endl; &#125; return 0;&#125; 速度 选择排序的复杂度为O(n2) 数据量 运行时间 5000 0.047s 20000 0.733s 50000 4.624s 100000 17.925s 插入排序介绍 所谓插入排序，就是将未排序区域的元素按大小插入已排序区域。它是一种稳定排序(stable sort)。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;ctime&gt;using namespace std;void _printf(int *a,int n)&#123; for(int i = 0;i &lt; n; i++)&#123; cout &lt;&lt; a[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl;&#125;void sort(int *a,int n)&#123; for(int i = 1;i &lt; n; i++)&#123;//element before i finished sort for(int j = 0;j &lt; i; j++)&#123; if(a[i] &lt; a[j])&#123; int x = a[i]; for(int y = i;y &gt; j; y--)&#123; a[y] = a[y - 1]; &#125; a[j] = x; break; &#125; &#125; //_printf(a,n); &#125;&#125;int main()&#123; int n; while(cin &gt;&gt; n)&#123; int *a = new int[n]; for(int i = 0;i &lt; n; i++)&#123; cin &gt;&gt; a[i]; &#125; clock_t begin,stop; double runtime; cout &lt;&lt; "Start" &lt;&lt; endl; begin = clock(); sort(a,n); stop = clock(); _printf(a,n); runtime = (double)(stop - begin)/CLOCKS_PER_SEC; cout &lt;&lt; "runtime " &lt;&lt; runtime &lt;&lt; "s" &lt;&lt; endl; &#125; return 0;&#125; 速度 插入排序的复杂度为O(n2) 数据量 运行时间 5000 0.031s 20000 0.550s 50000 3.569s 100000 13.799s 总结 排序算法 稳定性 平均情况 最好情况 最坏情况 辅助储存 冒泡排序 稳定 O(n2) O(n) O(n2) O(1) 选择排序 不稳定 O(n2) O(n2) O(n2) O(1) 插入排序 稳定 O(n2) O(n) O(n2) O(1)]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(23)】校门外的树 UESTC - 62]]></title>
    <url>%2F2017%2F12%2F16%2F23-%E6%A0%A1%E5%9B%AD%E5%A4%96%E7%9A%84%E6%A0%91%2F</url>
    <content type="text"><![CDATA[校门外的树 UESTC - 62 某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。马路上有一些区域要用来建地铁，这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。 Input 输入的第一行有两个整数L（1 &lt;= L &lt;= 10000）和 M（1 &lt;= M &lt;= 100），L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。 Output 输出包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。 Sample Input 500 3150 300100 200470 471 Sample Output 298 题意 原谅我再来一道水题，今天A了一些题，而且还卡了一些题，但是代码写得不漂亮，以后再看看吧=-= 题解1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main(void)&#123; int i = 0,l,n,cnt = 0; int *p; scanf("%d %d",&amp;l,&amp;n); p = (int *)malloc(sizeof(int) * (l + 1)); memset(p,1,sizeof(int) * (l + 1)); for(i = 0;i &lt; n; i++)&#123; int x,a,b; scanf("%d %d",&amp;a,&amp;b); for(x = a;x &lt;= b; x++) p[x] = 0; &#125; for(i = 1;i &lt;= l; i++)&#123; if(p[i] == 1) cnt++; &#125; printf("%d\n",cnt + 1); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(22)】Hamburgers Codeforces Round]]></title>
    <url>%2F2017%2F12%2F15%2F22-Hamburgers%2F</url>
    <content type="text"><![CDATA[Hamburgers Codeforces Round #218 (Div. 2) Polycarpus loves hamburgers very much. He especially adores the hamburgers he makes with his own hands. Polycarpus thinks that there are only three decent ingredients to make hamburgers from: a bread, sausage and cheese. He writes down the recipe of his favorite “Le Hamburger de Polycarpus” as a string of letters ‘B’ (bread), ‘S’ (sausage) и ‘C’ (cheese). The ingredients in the recipe go from bottom to top, for example, recipe “ВSCBS” represents the hamburger where the ingredients go from bottom to top as bread, sausage, cheese, bread and sausage again. Polycarpus has nb pieces of bread, ns pieces of sausage and nc pieces of cheese in the kitchen. Besides, the shop nearby has all three ingredients, the prices are pb rubles for a piece of bread, ps for a piece of sausage and pc for a piece of cheese. Polycarpus has r rubles and he is ready to shop on them. What maximum number of hamburgers can he cook? You can assume that Polycarpus cannot break or slice any of the pieces of bread, sausage or cheese. Besides, the shop has an unlimited number of pieces of each ingredient. Input The first line of the input contains a non-empty string that describes the recipe of “Le Hamburger de Polycarpus”. The length of the string doesn’t exceed 100, the string contains only letters ‘B’ (uppercase English B), ‘S’ (uppercase English S) and ‘C’ (uppercase English C). The second line contains three integers nb, ns, nc (1 ≤ nb, ns, nc ≤ 100) — the number of the pieces of bread, sausage and cheese on Polycarpus’ kitchen. The third line contains three integers pb, ps, pc (1 ≤ pb, ps, pc ≤ 100) — the price of one piece of bread, sausage and cheese in the shop. Finally, the fourth line contains integer r (1 ≤ r ≤ 1012) — the number of rubles Polycarpus has. Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier. Output Print the maximum number of hamburgers Polycarpus can make. If he can’t make any hamburger, print 0. Example Input BBBSSC 6 4 1 1 2 3 4 Output 2 Input BBC 1 10 1 1 10 1 21 Output 7 Input BSC 1 1 1 1 1 3 1000000000000 Output 200000000001 题意 昨天因为事情太多，没来得及更新，那就今天补两篇吧。这题我们可以看到数据特别大，所以该用long long就别漏掉了而且要用二分，复杂度为O(logn) 题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;#define inf 2000000000000long long int money;int b = 0,s = 0,c = 0;int nb,ns,nc;int pb,ps,pc;int jud(long long int mid,long long int &amp;m)&#123; long long int bb = (mid*b) - nb; long long int ss = (mid*s) - ns; long long int cc = (mid*c) - nc; if(bb &lt; 0) bb = 0; if(ss &lt; 0) ss = 0; if(cc &lt; 0) cc = 0; m = (bb)*pb + (ss)*ps + (cc)*pc; if(m &gt; money) return 1; else return 0;&#125;int main()&#123; char x; while(scanf("%c",&amp;x) &amp;&amp; x != '\n')&#123; switch(x)&#123; case 'B': b++;break; case 'S': s++;break; case 'C': c++;break; &#125; &#125; cin &gt;&gt; nb &gt;&gt; ns &gt;&gt; nc; cin &gt;&gt; pb &gt;&gt; ps &gt;&gt; pc; cin &gt;&gt; money; long long int l = 1,r = inf,cnt = -1; while(l &lt;= inf &amp;&amp; l &lt; r)&#123; long long int mid = (l + r)/2,m; int judge = jud(mid,m); if(judge == 0)&#123; cnt = cnt &gt; m?cnt : m; l = mid + 1; &#125;else&#123; r = mid; &#125; &#125; cout &lt;&lt; l - 1 &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(21)】轰炸区最优选取 2017年哈尔滨理工大学新生赛低年级组 - D]]></title>
    <url>%2F2017%2F12%2F13%2F21-%E8%BD%B0%E7%82%B8%E5%8C%BA%E6%9C%80%E4%BD%B3%E9%80%89%E5%8F%96%2F</url>
    <content type="text"><![CDATA[轰炸区最优选取 2017年哈尔滨理工大学新生赛低年级组 - D 时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld 题目描述 现在给出一个正方形地图，其边长为n，地图上有的地方是空的，有的地方会有敌人。我们现在有一次轰炸敌人的机会，轰炸敌人的区域是一个k*k的正方形区域，现在需要你解决的问题就是计算最多轰炸的敌人数量是多少。 输入描述 本题包含多组数据，每组数据第一行输入两个数n，k。接下来n行，每行n个数字，表示这个点上的敌人数量。数据范围：1&lt;=n&lt;=501&lt;=k&lt;=n每个点上的敌人数量不超过100个（0&lt;=a[i][j]&lt;=100）。输出描述:每组数据输出包含一行，表示计算的结果。 输入 4 21 1 0 01 1 0 00 0 2 20 0 2 2 输出 8 说明 样例中，显然轰炸右下角那个部分能够击败最多的敌人 题意 这显然是一道搜索题，不知道有没有更好的算法 题解123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int cnt(int x,int y);int a[55][55];int n,k;int main()&#123; while(cin&gt;&gt;n&gt;&gt;k)&#123; for(int i = 0;i &lt; n; i++) for(int j = 0;j &lt; n; j++) cin &gt;&gt; a[i][j]; int max = -1; for(int i = k - 1;i &lt; n; i++)&#123; for(int j = k - 1;j &lt; n; j++)&#123; int x = cnt(i,j); max = max &gt; x ? max : x; &#125; &#125; cout &lt;&lt; max &lt;&lt; endl; &#125; return 0;&#125;int cnt(int x,int y)&#123; int cnt = 0; for(int i = x;i &gt;= x- k + 1; i--) for(int j = y;j &gt;= y - k + 1; j--) cnt += a[i][j]; return cnt;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(20)】数圈圈 2017年哈尔滨理工大学新生赛低年级组 - E]]></title>
    <url>%2F2017%2F12%2F12%2F20-%E6%95%B0%E5%9C%88%E5%9C%88%2F</url>
    <content type="text"><![CDATA[数圈圈 2017年哈尔滨理工大学新生赛低年级组 - E 时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld 题目描述 tabris有一个习惯，无聊的时候就会数圈圈，无论数字还是字母。现在tabris更无聊啦，晚上睡不着觉就开始数羊，从a只数到b只。顺便还数了a到b之间有多少个圈。 但是tabris笨啊，虽然数羊不会数错，但很可能数错圈的个数。但是tabris很难接受自己笨这个事实，所以想问问你他一共应该数出多少个圈，这样tabris才好判断他到底笨不笨啊。 输入描述 输入一个T，表示数据组数每组测试数据包含两个正整数a，b。T∈[1,50]a,b∈[1,106] 输出描述 每组数据输出结果，并换行。 输入 111 12 23 34 45 56 67 78 89 910 101 100 输出 0001010211111 备注 数字的圈的个数请根据样例自行理解。 题意 这个题一开始我以为要预处理，但是发现没有预处理也可以过，表示惊呆 题解123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;char a[1000005];int b[10] = &#123;1,0,0,0,1,0,1,0,2,1&#125;;int main()&#123; for(int i = 0;i &lt; 1000005; i++)&#123; int n = i,cnt = 0; while(n)&#123; cnt += b[n%10]; n /= 10; &#125; a[i] = cnt; &#125; int l,h,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d %d",&amp;l,&amp;h); int cnt = 0; for(int i = l;i &lt;= h; i++)&#123; cnt += a[i]; &#125; printf("%d\n",cnt); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(19)】A + B Problem II(大数相加) HDU - 1002]]></title>
    <url>%2F2017%2F12%2F11%2F19-%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0A-B-Problem-II%2F</url>
    <content type="text"><![CDATA[A + B Problem II(大数相加) HDU - 1002 I have a very simple problem for you. Given two integers A and B, your job is to calculate the Sum of A + B. Input The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line consists of two positive integers, A and B. Notice that the integers are very large, that means you should not process them by using 32-bit integer. You may assume the length of each integer will not exceed 1000. Output For each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line is the an equation “A + B = Sum”, Sum means the result of A + B. Note there are some spaces int the equation. Output a blank line between two test cases. Sample Input 21 2112233445566778899 998877665544332211 Sample Output Case 1:1 + 2 = 3 Case 2:112233445566778899 + 998877665544332211 = 1111111111111111110 题意 题目就是要模拟大数相加，所以我们把人类算数字相加模拟一下就行了；这道题格式错误了7次，尴尬，一直找不出输出格式啥意思，看了几遍才懂T_T 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int main(void)&#123; int n; scanf("%d\n",&amp;n); int t = 0; while(n--)&#123; char a[10005] = &#123;0&#125;,b[10005] = &#123;0&#125;,a1[10005] = &#123;0&#125;,b1[10005] = &#123;0&#125;,c[10005] = &#123;0&#125;; scanf("%s %s",a,b); int lena = strlen(a); int lenb = strlen(b); for(int i = 0;i &lt; lena; i++) a1[lena - i - 1] = a[i]; a1[lena] = 0; for(int i = 0;i &lt; lenb; i++) b1[lenb - i - 1] = b[i]; b1[lenb] = 0; int maxlen = lena &gt; lenb? lena : lenb; for(int i = lena;i &lt; maxlen; i++) a1[i] = '0'; a1[maxlen] = 0; for(int i = lenb;i &lt; maxlen; i++) b1[i] = '0'; b1[maxlen] = 0; int fit = 0; for(int i = 0;i &lt; maxlen; i++)&#123; c[i] = a1[i] - '0' + b1[i] - '0' + fit; if(c[i] &gt; 9)&#123; fit = 1; c[i] = c[i] - 10 + '0'; &#125; else&#123; fit = 0; c[i] += '0'; &#125; &#125; if(fit == 1)&#123; c[maxlen] = '1'; maxlen += 1; &#125; t++; cout&lt;&lt;"Case "&lt;&lt;t&lt;&lt;":"&lt;&lt;endl; cout&lt;&lt; a &lt;&lt;" + "&lt;&lt;b&lt;&lt;" = "; for(int i = maxlen - 1;i &gt;= 0; i--)&#123; cout &lt;&lt; c[i]; &#125; cout &lt;&lt; endl; if(n != 0) cout &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(18)】cayun日常之赏月 2017年浙江工业大学迎新赛热身赛-L]]></title>
    <url>%2F2017%2F12%2F10%2F18-cayun%E6%97%A5%E5%B8%B8%E4%B9%8B%E8%B5%8F%E6%9C%88%E6%9C%88%2F</url>
    <content type="text"><![CDATA[cayun日常之赏月 2017年浙江工业大学迎新赛热身赛-L 时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 131072K，其他语言262144K64bit IO Format: %lld 题目描述 在cayun星球月亮大小都有一个规律，月亮为每30天一个周期，在这30天的周期里，月亮的大小分别为0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1，虽然天气很冷，但某个cayun今天却异常疯癫，不知为何居然想要赏月了。但他想在赏月之前知道今天的月亮到底有多大。 输入描述 第一行数据组数T(T &lt;= 30)，对于每组数据两个整数a, b(0 &lt;= a, b &lt;= 15)，表示前两天的月亮大小，保证数据是合法的。 输出描述 每组数据占一行，表示今天的月亮大小。 输入 20 111 10 输出 29 题意 因为今天的STL题都没A，我也不知为啥T_T，今天只A了两道水题，不愉快的周末不愉快的周末T_T 题解123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int m[34] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3&#125;; int a,b,t; scanf("%d",&amp;t); while(t--)&#123; while(scanf("%d %d",&amp;a,&amp;b) != EOF)&#123; for(int i = 0;i &lt; 30; i++)&#123; if(a == m[i] &amp;&amp; b == m[i + 1])&#123; cout &lt;&lt; m[i + 2] &lt;&lt; endl; break; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(17)】Where is the Marble? UVA - 10474]]></title>
    <url>%2F2017%2F12%2F09%2F17-Where-is-the-Marble%2F</url>
    <content type="text"><![CDATA[Where is the Marble? UVA - 10474 Raju and Meena love to play with Marbles. They have got a lot ofmarbles with numbers written on them. At the beginning, Raju wouldplace the marbles one after another in ascending order of the numberswritten on them. Then Meena would ask Raju to find the first marblewith a certain number. She would count 1…2…3. Raju gets one pointfor correct answer, and Meena gets the point if Raju fails. After somefixed number of trials the game ends and the player with maximumpoints wins. Today it’s your chance to play as Raju. Being the smartkid, you’d be taking the favor of a computer. But don’t underestimateMeena, she had written a program to keep track how much time you’retaking to give all the answers. So now you have to write a program,which will help you in your role as Raju. Input There can be multiple test cases. Total no of test cases is less than 65. Each test case consists beginswith 2 integers: N the number of marbles and Q the number of queries Mina would make. The nextN lines would contain the numbers written on the N marbles. These marble numbers will not comein any particular order. Following Q lines will have Q queries. Be assured, none of the input numbersare greater than 10000 and none of them are negative.Input is terminated by a test case where N = 0 and Q = 0. Output For each test case output the serial number of the case.For each of the queries, print one line of output. The format of this line will depend upon whetheror not the query number is written upon any of the marbles. The two different formats are describedbelow:• ‘x found at y’, if the first marble with number x was found at position y. Positions are numbered1, 2, . . . , N.• ‘x not found’, if the marble with number x is not present.Look at the output for sample input for details. Sample Input 4 1235155 213331230 0 Sample Output CASE# 1:5 found at 4CASE# 2:2 not found3 found at 3 题意 题目不难理解，就是排序然后输出某一个大理石的位置，用STL可以解决，或者数组也行，都是一样的，这道题WA了3次T_T，第一次数组越界，第二次还是数组越界，第三次多了个空格输出格式错误T_T 题解1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a,b,cnt = 1; while(cin &gt;&gt; a &gt;&gt; b)&#123; vector&lt;int&gt;vec; if(a == 0 &amp;&amp; b == 0) break; while(a--)&#123; int t; cin &gt;&gt; t; vec.push_back(t); &#125; cout &lt;&lt; "CASE# " &lt;&lt; cnt &lt;&lt; ":" &lt;&lt; endl; sort(vec.begin(),vec.begin() + vec.size()); while(b--)&#123; int t; cin &gt;&gt; t; int p = lower_bound(vec.begin(),vec.begin() + vec.size(),t) - vec.begin(); if(vec[p] == t) cout &lt;&lt; t &lt;&lt; " found at " &lt;&lt; p + 1 &lt;&lt; endl; else cout &lt;&lt; t &lt;&lt; " not found" &lt;&lt; endl; &#125; cnt++; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(16)】毕业设计选题 2017年浙江工业大学迎新赛热身赛-A]]></title>
    <url>%2F2017%2F12%2F08%2F16-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E9%80%89%E9%A2%98%2F</url>
    <content type="text"><![CDATA[毕业设计选题 2017年浙江工业大学迎新赛热身赛-A 时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 65536K，其他语言131072K64bit IO Format: %lld 题目描述 又到了一年一度，大四老学长们毕业设计选题的时候，一般指导老师都会为学生提供若干个选题供学生选择。大家都知道，有的课题，看上去高大上，实则含金量不高，有的课题看似简单，但实际难度却非常大，也有的课题，没有什么太大难度，但却异常繁琐，工作量极大。现大致评估出每个课题的高大上值，实际工作量。已知小飞学长，是个懒惰的家伙，但却又极好面子，因此，请帮他找出高大上值和实际工作量比值最大的课题。 输入描述 共有T组数据。（T&lt;=10），每组数据第一行有一个整数n（n&lt;=200000），接下来n行，每行一个课题名称（只包含大小写字母，长度小于40），以及该课题的高大上值v，以及其工作量w。（v,w都是小于109的整数）。 输出描述 对于每组样例输出一个课题名称，代表该组样例中高大上值和实际工作量比值最大的课题（保证唯一）。 输入 12CloudComputingBasedOnDistributedSystems 5 2PotentialRisksInRegularSystem 4 2 输出 CloudComputingBasedOnDistributedSystems 题意 略 题解123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int main() &#123; int t,n; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); char ename[42],name[42]; int vip = -1; while(n--)&#123; double w,v; scanf("%s %lf %lf",name,&amp;w,&amp;v); if(w/v &gt; vip)&#123; strcpy(ename, name); vip = w/v; &#125; &#125; cout &lt;&lt; ename &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(15)】超级楼梯 HDU - 2041]]></title>
    <url>%2F2017%2F12%2F07%2F15-%E8%B6%85%E7%BA%A7%E6%A5%BC%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[超级楼梯 HDU - 2041 有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？ Input 输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数。 Output 对于每个测试实例，请输出不同走法的数量 Sample Input 223 Sample Output 12 题意 这是一道经典的递归题(这几天的经典台词T_T没时间只能做水题)用数组减少计算时间和次数； 题解123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long int run(int m);long long int a[42] = &#123;0,0,1&#125;;int main(void)&#123; int n,m; cin &gt;&gt; n; while(n--)&#123; cin &gt;&gt; m; cout &lt;&lt; run(m) &lt;&lt; endl; &#125; return 0;&#125;long long int run(int m)&#123; if(m &lt;=2) return 1; else&#123; if(a[m] == 0) a[m] = run(m - 1) + run(m - 2); return a[m]; &#125;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(14)】函数F(x) HRBUST - 1990]]></title>
    <url>%2F2017%2F12%2F06%2F14-%E5%87%BD%E6%95%B0F-x%2F</url>
    <content type="text"><![CDATA[函数F(x) HRBUST - 1990 我们定义一个函数F（x）=k;即是x的因子数目为k,例如F(3)=2,3的因子为1和3，F(4)=3,4的因子有1,2,4三个，接下来问题来了，现在给你一个整数k,求满足函数F(x)=k的最小x。（题目中所涉及的整数均为正整数）。 Input 本题有多组测试数据，每组数据的第一行有一个整数n,表示有n组询问（1&lt;n&lt;=10）； 接下来n行，每行有一个整数k(0&lt;k&lt;=100)； Output 输出包括一行，这一行只包含一个整数，既满足题目要求的数x，如果x大于1000，输出-1。 Sample Input 37252 Sample Output 64-12 题意 略 题解12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(void)&#123; int i,j,u,n,k,cnt; while(scanf("%d",&amp;n) != EOF)&#123; for(u = 0;u &lt; n;u ++)&#123; scanf("%d",&amp;k); cnt = 0; for(i = 1;cnt != k; i++)&#123; cnt = 0; for(j = 1;j &lt;= sqrt(i); j++)&#123; if(i%j == 0)&#123; if((double)(j) == sqrt(i)) cnt++; else cnt += 2; &#125; &#125; if(i &gt; 1000)&#123; printf("-1\n"); break; &#125; &#125; if(i &lt; 1001) printf("%d\n",i - 1); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(13)】数字三角形 UESTC - 1011]]></title>
    <url>%2F2017%2F12%2F05%2F13-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[数字三角形 UESTC - 1011 73 88 1 02 7 4 44 5 2 6 5(Figure 1)Figure 1 shows a number triangle. Write a program that calculates the highest sum of numbers passed on a route that starts at the top and ends somewhere on the &gt;base. Each step can go either diagonally down to the left or diagonally down to the right. Input Your program is to read from standard input. The first line contains one integer N: the number of rows in the triangle. The following N lines describe the data of &gt;the triangle. The number of rows in the triangle is &gt; 1 but &lt;= 100. The numbers in the triangle, all integers, are between 0 and 99. Output Your program is to write to standard output. The highest sum is written as an integer. Sample Input 573 88 1 02 7 4 44 5 2 6 5 Sample Output 30 题意 这是动态规划入门题，要寻找全局最优解，所以要从底开始向上算，这样子才可以找出全局最优解 题解1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void)&#123; int n,i,j; scanf("%d",&amp;n); int **a; a = (int **)malloc(sizeof(int *) * n); for(i = 0;i &lt; n; i++) a[i] = (int *)malloc(sizeof(int) * n); for(i = 0;i &lt; n; i++) for(j = 0;j &lt;= i; j++) scanf("%d",&amp;a[i][j]); for(i = n - 1;i &gt; 0; i--) for(j = 0;j &lt;= i; j++) if(a[i][j] &gt; a[i][j + 1]) a[i - 1][j] = a[i][j] + a[i - 1][j]; else a[i - 1][j] = a[i][j + 1] + a[i - 1][j]; printf("%d\n",a[0][0]); return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(12)】Windows Message Queue ZOJ - 2724]]></title>
    <url>%2F2017%2F12%2F04%2F12-Windows-Message-Queue-2%2F</url>
    <content type="text"><![CDATA[Windows Message Queue Message queue is the basic fundamental of windows system. For each process, the system maintains a message queue. If something happens to this process, such as mouse click, text change, the system will add a message to the queue. Meanwhile, the process will do a loop for getting message from the queue according to the priority value if it is not empty. Note that the less priority value means the higher priority. In this problem, you are asked to simulate the message queue for putting messages to and getting message from the message queue. Input There’s only one test case in the input. Each line is a command, “GET” or “PUT”, which means getting message or putting message. If the command is “PUT”, there’re one string means the message name and two integer means the parameter and priority followed by. There will be at most 60000 command. Note that one message can appear twice or more and if two messages have the same priority, the one comes first will be processed first.(i.e., FIFO for the same priority.) Process to the end-of-file. Output For each “GET” command, output the command getting from the message queue with the name and parameter in one line. If there’s no message in the queue, output “EMPTY QUEUE!”. There’s no output for “PUT” command. Sample Input GETPUT msg1 10 5PUT msg2 10 4GETGETGET Sample Output EMPTY QUEUE!msg2 10msg1 10EMPTY QUEUE! 题意 这题是一道基础的STL的优先队列题，很简单，直接上代码 题解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;iostream&gt;using namespace std;struct node&#123; char name[101]; int cont,vip,x; friend bool operator &lt; (node a, node b) &#123; if(a.vip != b.vip) return a.vip &gt; b.vip; else return a.x &gt; b.x; &#125;&#125;;int cnt = 0;int main(void)&#123; struct node msg; char input[5]; priority_queue&lt;node&gt; q; while(scanf("%s",&amp;input) != EOF) &#123; if(strcmp(input,"GET") == 0) &#123; if(q.empty()) printf("EMPTY QUEUE!\n"); else &#123; msg = q.top(); q.pop(); printf("%s %d\n", msg.name , msg.cont); cnt--; &#125; &#125; else &#123; scanf("%s %d %d",&amp;msg.name,&amp;msg.cont,&amp;msg.vip); msg.x = cnt; q.push(msg); cnt++; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(11)】Wine Trading in Gergovia POJ - 2940]]></title>
    <url>%2F2017%2F12%2F03%2F11-Wine-Trading-in-Gergovia%2F</url>
    <content type="text"><![CDATA[Wine Trading in Gergovia POJ - 2940 As you may know from the comic “Asterix and the Chieftain’s Shield”, Gergovia consists of one street, and every inhabitant of the city is a wine salesman. You wonder how this economy works? Simple enough: everyone buys wine from other inhabitants of the city. Every day each inhabitant decides how much wine he wants to buy or sell. Interestingly, demand and supply is always the same, so that each inhabitant gets what he wants. There is one problem, however: Transporting wine from one house to another results in work. Since all wines are equally good, the inhabitants of Gergovia don’t care which persons they are doing trade with, they are only interested in selling or buying a specific amount of wine. They are clever enough to figure out a way of trading so that the overall amount of work needed for transports is minimized. In this problem you are asked to reconstruct the trading during one day in Gergovia. For simplicity we will assume that the houses are built along a straight line with equal distance between adjacent houses. Transporting one bottle of wine from one house to an adjacent house results in one unit of work. Input The input consists of several test cases. Each test case starts with the number of inhabitants n (2 ≤ n ≤ 100000). The following line contains n integers ai (−1000 ≤ ai ≤ 1000). If ai ≥ 0, it means that the inhabitant living in the ith house wants to buy ai bottles of wine, otherwise if ai &lt; 0, he wants to sell −ai bottles of wine. You may assume that the numbers ai sum up to 0. The last test case is followed by a line containing 0. Output For each test case print the minimum amount of work units needed so that every inhabitant has his demand fulfilled. You may assume that this number fits into a signed 64-bit integer (in C/C++ you can use the data type “long long” or “__int64”, in JAVA the data type “long”). Sample Input 55 -4 1 -3 16-1000 -1000 -1000 1000 1000 10000 Sample Output 99000 题意 有一条线性的村子，里面的人很懒，每天只做一件事，就是买酒(+)和卖酒(-)，求最少的工作量；我最初的想法是遍历全部村子，对应的找出每个买酒的人，卖给最近的，而这个算法的复杂度是O(nlogn);然后我看了一下大牛的做法，发现了原来还有线性O(n)的算法；以下我会分两个代码，分别实现我的傻傻的算法和大牛的超级算法； 题解我的算法123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std;int main(void)&#123; int n,i,j; while(scanf("%d",&amp;n) != EOF &amp;&amp; n != 0) &#123; int *a = new int[n];//建立n户人家的数组 int mark = 0; long long int ans = 0; for(i = 0;i &lt; n;i++) scanf("%d",&amp;a[i]); for(i = 0;i &lt; n; i++) &#123; if(a[i] &gt; 0)//从左到右找出需要买酒的人家 &#123; for(j = mark;j &lt; n; j++) &#123; if(a[j] &lt; 0)//从左到右找出卖酒的人家 &#123; ans += (abs(j - i)*((abs(a[i]) &lt; abs(a[j]))?abs(a[i]):abs(a[j]))); int t = a[j]; a[j] = ((a[i] + a[j]) &lt;= 0)?(a[i] + a[j]):0; a[i] = ((a[i] + t) &gt;= 0)?(a[i] + t):0; if(a[j] == 0) mark = j;//标记卖酒的人家，下次循环不必从0开始； if(a[i] == 0) break;//如果买到想要的酒了，就不必退出寻找卖家 &#125; &#125; &#125; &#125; printf("%I64d\n",ans); &#125; return 0;&#125; 大牛算法 从左到右，左边的酒总要到达最右端，记录从左到右酒走过的路径； 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long int abs(long long int sum);int main(void)&#123; int n; while(~scanf("%d",&amp;n) &amp;&amp; n != 0)&#123; long long int ans = 0,sum = 0; int a; while(n--)&#123; scanf("%d",&amp;a); sum = sum + a; ans += abs(sum); &#125; printf("%I64d\n",ans); &#125; return 0;&#125;long long int abs(long long int sum)&#123; return (sum &gt; 0)?sum:(-1*sum);&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(10)】Hero HDU-4310]]></title>
    <url>%2F2017%2F12%2F02%2F10-hero%2F</url>
    <content type="text"><![CDATA[Hero HDU-4310 When playing DotA with god-like rivals and pig-like team members, you have to face an embarrassing situation: All your teammates are killed, and you have to fight 1vN. There are two key attributes for the heroes in the game, health point (HP) and damage per shot (DPS). Your hero has almost infinite HP, but only 1 DPS. To simplify the problem, we assume the game is turn-based, but not real-time. In each round, you can choose one enemy hero to attack, and his HP will decrease by 1. While at the same time, all the lived enemy heroes will attack you, and your HP will decrease by the sum of their DPS. If one hero’s HP fall equal to (or below) zero, he will die after this round, and cannot attack you in the following rounds. Although your hero is undefeated, you want to choose best strategy to kill all the enemy heroes with minimum HP loss. Input The first line of each test case contains the number of enemy heroes N (1 &lt;= N &lt;= 20). Then N lines followed, each contains two integers DPSi and HPi, which are the DPS and HP for each hero. (1 &lt;= DPSi, HPi &lt;= 1000) Output Output one line for each test, indicates the minimum HP loss. Sample Input 110 22100 11 100 Sample Output 20201 题意 这是个很有趣的贪心题，首先将敌人从伤害平均值从高往低排序再一个个击倒，这道题中我使用的是STL中的优先队列 题解12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;struct node&#123; int hp,dps;//dps:伤害 hp:血量 double vip; friend bool operator &lt; (node a,node b)&#123;//重载STL的&lt;运算符; return a.vip &lt; b.vip; &#125;&#125;;int main(void)&#123; int n; while(scanf("%d",&amp;n) != EOF)&#123; priority_queue&lt;node&gt; q;//定义一个q优先队列 node v; int cnt = 0,count = 0; while(n--)&#123; scanf("%d %d",&amp;v.dps,&amp;v.hp); v.vip = (double)(v.dps)/(double)(v.hp);//将vip作为比较本体 count += v.dps; q.push(v); &#125; while(!q.empty())&#123; v = q.top(); cnt += (count * v.hp); count -= v.dps; q.pop(); &#125; printf("%d\n",cnt); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(9)】Duizi and Shunzi HDU - 6188 2017ACM/ICPC广西邀请赛]]></title>
    <url>%2F2017%2F12%2F01%2F9-Duizi-and-Shunzi%2F</url>
    <content type="text"><![CDATA[Duizi and Shunzi HDU - 6188 Nike likes playing cards and makes a problem of it. Now give you n integers, ai(1≤i≤n)ai(1≤i≤n) We define two identical numbers (eg: 2,2) a Duizi,and three consecutive positive integers (eg: 2,3,4) a Shunzi. Now you want to use these integers to form Shunzi and Duizi as many as possible. Let s be the total number of the Shunzi and the Duizi you formed. Try to calculate max(s). Each number can be used only once. Input The input contains several test cases. For each test case, the first line contains one integer n(1≤n≤106).Then the next line contains n space-separated integers aiai (1≤ai≤n) Output For each test case, output the answer in a line. Sample Input 71 2 3 4 5 6 791 1 1 2 2 2 3 3 362 2 3 3 3 361 2 3 3 4 5 Sample Output 2432 Hint Case 1（1，2，3）（4，5，6） Case 2（1，2，3）（1，1）（2，2）（3，3） Case 3（2，2）（3，3）（3，3） Case 4（1，2，3）（3，4，5） 题意 题目大意：每两个同样的数字可以组成对子，每三个连续的数字可以组成顺子于是，我们可以通过栈或者数组来解决这个问题 1 1 2 3 我们可以组成 (1 1) 2 3 或者 1（1 2 3）;都是一个，并没有区别1 2 2 3 我门可以组成 1 (2 2) 3 或者 2 (1 2 3);都是一个，并没有区别1 2 3 3 我们可以组成 1 2 (3 3) 或者 (1 2 3) 3;对于这种情况而言，组成对子，一定是一种可能，而组成顺子时，3这个数字可能可以和后面出现的数组成更多对子或顺子； 在这题中，我会写出我理解中的两种做法，一种是数组，一种是栈 题解数组解法12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;int main(void)&#123; char a[1000500]; int n,i,x; while(scanf("%d",&amp;n) != EOF) &#123; memset(a,0,sizeof(a)); int duizi = 0,shunzi = 0; for(i = 1;i &lt;= n; i++) &#123; scanf("%d",&amp;x); a[x]++; &#125; for(i = 1;i &lt;= 1000500; i++) &#123; if(a[i] &gt;= 2) &#123; duizi = a[i]/2 + duizi; a[i] = a[i]%2; &#125; if(i &lt; 1000498) &#123; if(a[i] == 1 &amp;&amp; a[i + 1]%2 == 1 &amp;&amp; a[i + 2] != 0) &#123; shunzi++; a[i]--; a[i + 1]--; a[i + 2]--; &#125; &#125; &#125; printf("%d\n",shunzi + duizi); &#125; return 0;&#125; 栈的解法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;struct node&#123; int x; friend bool operator &lt; (node a, node b) &#123; return a.x &gt; b.x; &#125;&#125;;int main(void)&#123; int n; while(~scanf("%d",&amp;n))&#123; stack&lt;int&gt;s; node i; priority_queue&lt;node&gt; q; int k = n; int a,duizi = 0,shunzi = 0; while(k--)&#123; scanf("%d",&amp;a); i.x = a; q.push(i); &#125; while(n--)&#123; int a; node i; i = q.top(); a = i.x; q.pop(); if(!s.empty())&#123; if(a == s.top())&#123; s.pop(); duizi++; &#125;else if(!s.empty() &amp;&amp; a == (s.top() + 1))&#123; s.pop(); if(!s.empty() &amp;&amp; a == (s.top() + 2))&#123; s.pop(); shunzi++; &#125;else&#123; s.push(a - 1); s.push(a); &#125; &#125;else&#123; s.push(a); &#125; &#125;else&#123; s.push(a); &#125; &#125; printf("%d\n",shunzi + duizi); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(8)】Mammoth's Genome Decoding CodeForces - 747B]]></title>
    <url>%2F2017%2F11%2F30%2F8-Mammoth-s-Genome-Decoding%2F</url>
    <content type="text"><![CDATA[Mammoth’s Genome Decoding CodeForces - 747B The process of mammoth’s genome decoding in Berland comes to its end! One of the few remaining tasks is to restore unrecognized nucleotides in a found chain s. Each nucleotide is coded with a capital letter of English alphabet: ‘A’, ‘C’, ‘G’ or ‘T’. Unrecognized nucleotides are coded by a question mark ‘?’. Thus, s is a string consisting of letters ‘A’, ‘C’, ‘G’, ‘T’ and characters ‘?’. It is known that the number of nucleotides of each of the four types in the decoded genome of mammoth in Berland should be equal. Your task is to decode the genome and replace each unrecognized nucleotide with one of the four types so that the number of nucleotides of each of the four types becomes equal. Input The first line contains the integer n (4 ≤ n ≤ 255) — the length of the genome. The second line contains the string s of length n — the coded genome. It consists of characters ‘A’, ‘C’, ‘G’, ‘T’ and ‘?’. Output If it is possible to decode the genome, print it. If there are multiple answer, print any of them. If it is not possible, print three equals signs in a row: “===” (without quotes). Example Input 8 AG?C??CT Output AGACGTCT Input 4 AGCT Output AGCT Input 6 ????G? Output === Input 4 AA?? Output === Note In the first example you can replace the first question mark with the letter ‘A’, the second question mark with the letter ‘G’, the third question mark with the letter ‘T’, then each nucleotide in the genome would be presented twice. In the second example the genome is already decoded correctly and each nucleotide is exactly once in it. In the third and the fourth examples it is impossible to decode the genom. 题意 伯尔兰猛犸解码基因组的四种核苷酸数量应该是相等的。您的任务是解码基因组，并用四种类型中的一种替换每个未识别的核苷酸，以使四种类型中的每一种的核苷酸数量相等。判断4种核苷酸数量有没有可能相等，如果不可能，输出“===”，否则输出正确基因组（如果有多种，只需要输出其中一种） 题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(void)&#123; int n,i = 0; while(scanf("%d",&amp;n) != EOF) &#123; int a = 0,t = 0,c = 0,g = 0; char p[255]; //char *p; //p = (char *)malloc(sizeof(char) * n); scanf("%s",&amp;p); for(i = 0;i &lt; n; i++) &#123; switch(p[i]) &#123; case 'A': a++; break; case 'T': t++; break; case 'C': c++; break; case 'G': g++; break; &#125; &#125; if(n%4 == 0) &#123; int x = n/4; if(x &gt;= a &amp;&amp; x &gt;= t &amp;&amp; x &gt;= c &amp;&amp; x &gt;= g) &#123; int A = x - a,T = x - t,C = x - c, G = x - g; for(i = 0;i &lt; n; i++) &#123; if(p[i] == '?') &#123; if(A != 0) &#123; p[i] = 'A'; A--; //continue; &#125; else if(T != 0) &#123; p[i] = 'T'; T--; //continue; &#125; else if(C != 0) &#123; p[i] = 'C'; C--; //continue; &#125; else if(G != 0) &#123; p[i] = 'G'; G--; //continue; &#125; &#125; &#125; printf("%s\n",p); &#125; else printf("===\n"); &#125; else printf("===\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(7)】8球胜负(eight) UESTC - 24 (电子科技大学第六届ACM程序设计大赛)]]></title>
    <url>%2F2017%2F11%2F29%2F7-8qiushengfu%2F</url>
    <content type="text"><![CDATA[8球胜负(eight) UESTC - 24 8球是一种台球竞赛的规则。台面上有7个红球、7个黄球以及一个黑球，当然还有一个白球。对于本题，我们使用如下的简化规则：红、黄两名选手轮流用白球击打各自颜色的球，如果将该颜色的7个球全部打进，则这名选手可以打黑球，如果打进则算他胜。如果在打进自己颜色的所有球之前就把黑球打进，则算输。如果选手不慎打进了对手的球，入球依然有效。 现在给出打进的球（白球除外）的顺序，以及黑球由哪方打进，你的任务是判定哪方是胜者。 假设不会有一杆同时打进一颗黑球和其他彩球。 Input 输入包含多组数据。每组数据第一行是一个整数NN(1≤N≤15)，表示打进的球的个数，N=0表示结束。随后有一行，包含N个字符，依序表示打进的是何种球。如果是B，表示是红方打进的黑球，如果是L，表示是黄方打进的黑球。如果是Y则表示是黄球，R表示红球。字符间没有空格。 所有输入都满足如下条件：最后一颗球打进时这局比赛正好结束，而且打进的红球和黑球都不超过7个。 Output 对每组数据，输出一行。如果红方胜，输出Red；黄方胜，输出Yellow。 Sample Input 5RYRRB9RRRRYRRRB0 Sample Output YellowRed 题意 略 题解12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include &lt;string.h&gt;int main(void)&#123; int n; while(scanf("%d",&amp;n) != EOF || n != 0) &#123; int r = 0,y = 0,i = 0; char a[16]; scanf("%s",&amp;a); for(i = 0;i &lt; n; i++) &#123; if(a[i] == 'Y') y++; if(a[i] == 'R') r++; &#125; if(a[n - 1] == 'B') &#123; if(r == 7) printf("Red\n"); else printf("Yellow\n"); &#125; if(a[n - 1] == 'L') &#123; if(y == 7) printf("Yellow\n"); else printf("Red\n"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(6)】Div. 64 CodeForces - 887A]]></title>
    <url>%2F2017%2F11%2F28%2F6-Div-64%2F</url>
    <content type="text"><![CDATA[Div. 64 CodeForces - 887A Top-model Izabella participates in the competition. She wants to impress judges and show her mathematical skills. Her problem is following: for given string, consisting of only 0 and 1, tell if it’s possible to remove some digits in such a way, that remaining number is a representation of some positive integer, divisible by 64, in the binary numerical system. Input In the only line given a non-empty binary string s with length up to 100. Output Print «yes» (without quotes) if it’s possible to remove digits required way and «no» otherwise. Example Input 100010001 Output yes Input 100 Output no Note In the first test case, you can get string 1 000 000 after removing two ones which is a representation of number 64 in the binary numerical system. You can read more about binary numeral system representation here 题意 题目：输入一串二进制编码，问能否通过删除若干位数字使二进制编码变成64的倍数；显然，64(2) → 1000000 128(2) → 10000000 192(2) → 11000000 256(2) → 100000000即64的倍数在二进制中，后面必有6个0；题目便转化成了，判断1后是否存在6个或6个以上的0 题解123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char a[100]; while(scanf("%s",&amp;a) != EOF) &#123; int i,t,x = 0,len = strlen(a); for(i = 0;i &lt; len; i++) &#123; if(a[i] == '1') &#123; for(t = i + 1;t &lt; len; t++) &#123; if(a[t] == '0') x++; if(x == 6) break; &#125; &#125; if(t == len) break; &#125; if(x &gt;= 6) printf("yes\n"); else printf("no\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(5)】密码(凯撒密码) FZU - 1489 (福州大学第四届程序设计竞赛题)]]></title>
    <url>%2F2017%2F11%2F27%2F5-kai-sa-mi-ma%2F</url>
    <content type="text"><![CDATA[密码(凯撒密码) FZU - 1489 密码的使用最早可以追溯到古罗马时期，《高卢战记》有描述恺撒曾经使用密码来传递信息，即所谓的“恺撒密码”，它是一种替代密码，通过将字母按顺序推后3位起到加密作用，如将字母A换作字母D，将字母B换作字母E。据说恺撒是率先使用加密的古代将领之一，因此这种加密方法被称为恺撒密码。显然从1到25个位置的移位我们都可以使用， 因此，为了使密码有更高的安全性，我们可以使用单字母替换密码。 如： 明码表 ABCDEFGHIJKLMNOPQRSTUVWXYZ 密码表 QWERTYUIOPASDFGHJKLZXCVBNM 明文 Welcome to fzupc2007! 密文 Vtsegdt zg Ymxhe2007! 明文中的字母按明码表和密码表被替换成相应的密文字母。请编写一个程序在已知密码表（明码表不变）和明文的情况下加密后的密文。加密只针对英文字母，所有其他的符号都保持不变。 Input 本题有多组输入数据，你必须处理到EOF为止 每组输入数据有2行，第一行为密码表共有26个英文大写字符，第二行为密文，密文不超过100个字符。输入数据由字母、空格、数字以及各种标点组成。 Output 输出只有一行为加密后的明文（大小写字母加密方式相同,且替换后大小写方式不变）。 Sample Input QWERTYUIOPASDFGHJKLZXCVBNMWelcome to Fzupc2007! Sample Output Vtsegdt zg Ymxhe2007! 题意 显然，要使密码和明文配对，只需要密码字母相同的个数和明文字母相同的个数完全一样就可以了，例如只换字母不换顺序：hello （1H 1E 2L 1O） → nlbbq (1N 1L 2B 1Q) 可见，密码交换后，字母个数还是1，1，2，1既换字母也换顺序：hello （1H 1E 2L 1O） → blbqn (1N 1L 2B 1Q) 可见，密码交换后，字母个数还是1，1，2，1显然可以看出，不管换字母还是换顺序，字母个数都是一一对应的 题解123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(void)&#123; char a[30],b[200]; int i; while(scanf("%s",a) != EOF)&#123; getchar(); gets(b); int x = strlen(b); for(i = 0;i &lt; x; i++)&#123; if(b[i] &gt;= 'a' &amp;&amp; b[i] &lt;= 'z') b[i] = a[b[i] - 'a'] + 32; if(b[i] &gt;= 'A' &amp;&amp; b[i] &lt;= 'Z') b[i] = a[b[i] - 'A']; &#125; puts(b); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于位运算的笔记]]></title>
    <url>%2F2017%2F11%2F27%2FNoteAbout_bitwise%20operation%2F</url>
    <content type="text"><![CDATA[前言2017年11月19日关于学习位操作，我可能会阐述个人理解以及在实际生活和在编程中的使用，将位操作和生活和编程更好的联系起来，以帮助自己理解，使学习更加深入，所以可能会有一些误解和错误的方面，希望可以和本人交流指出错误之处，感激不尽。 二进制1.0b表示二进制数，但是C中不可用。2.一个字节中有8位(bit)，无符号可以表示0~255之间的数字（unsigned char）；有符号可表示-128~+127（signed char）； 二进制浮点型1.使用幂作为分母例如 2^(-1);2.二进制只能精确表示多个1/2的幂之和; 按位运算逻辑运算符按位运算逻辑运算符：~（取反）、&amp;（按位与）、|（按位或），^（按位异或）； 取反取反~：每一位上0变1，1变0； a ~a 0 1 1 0 ~11001100 = 00110011 按位与按位与&amp;：每一位上其中一个为0则取0，都为1则取1； a b a&amp;b 0 0 0 0 1 0 1 0 0 1 1 1 10010011 &amp; 00111101 = 0010001 按位或按位或|：每一位上其中一个为1则取1，都为0则取0； a b a或b 0 0 0 0 1 1 1 0 1 1 1 1 10010011 | 00111101 = 10111111 按位异或按位异或^:每一位上两个相同则为0，不同则为1； a b a^b 0 0 0 0 1 1 1 0 1 1 1 0 10010011^00111101 = 10101110 异或特性异或偶数次会变回原来的数字 移位运算符左移： &lt;&lt; 左移运算符将原有的数字向左移动指定的位数；移出左末端的位数将会丢失，而右端则会用‘0’补充空缺的位置。 (10001010) &lt;&lt; 2 = (00101000) //可以看出，数字向左移动两位，左末端数字丢失，右端补‘0’这样的操作产生了新的数字，但是并不会赋值，例如12int num = 1;num &lt;&lt; 2; 这种操作中，num依旧是1，并不会有任何改变；若需要改变变量，则需要 &lt;&lt;= 来实现；12int num = 1;num &lt;&lt;= 2; //等价于 num = num &lt;&lt; 2; 右移： &gt;&gt; 与左移基本相同；在右移运算中，右末端位数将会丢失；但是，对于左末端而言。对于无符号类型，将会用‘0’补齐空位；而对于有符号类型，结果将取决于机器，空出的符号可用‘0’补充，或者用符号位的副本补充。例如：12(10001010) &gt;&gt; 2(00100010) 12(10001010) &gt;&gt; 2(11100010) 以上是有符号类型在不同机器上的不同运算结果，而下面是无符号类型的运算结果 12(10001010) &gt;&gt; 2(00100010) 右移运算符（&gt;&gt;=）与左移运算符用法基本相同； 移位运算符的用法移位运算符针对2的幂提供快速有效的乘法和除法：12number &lt;&lt; n; //number 乘于 2 的 n 次幂number &lt;&lt; n; //number 除于 2 的 n 次幂 这些运算相当于十进制中移动小数点来乘于10或除于10的操作。 代码实例12345678910111213141516171819202122//用移位制作流水灯项目#include&lt;reg52.h&gt;void delay(int t); //设置延时函数delay( ms)int main(void)&#123; unsigned int i = 0; while(1)&#123; for(i = 0;i &lt;= 7; i++)&#123; P1 = ~(0x01 &lt;&lt; i); //利用取反和移位实现LED灯流水效果 delay(100); &#125; for(i = 0;i &lt;= 7; i++)&#123; P1 = ~(0x80 &gt;&gt; i); delay(100); &#125; &#125; return 0;&#125;void delay(int t)&#123; int i; while(t--) for( i = 0;i &lt; 70;i++);&#125; 参考书籍《C Primer Plus》,《C和指针》,《C语言从入门到精通》,《编码(code):隐匿在计算机软硬件背后的语言》,《手把手教你学51单片机》]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>笔记</tag>
        <tag>学习</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(4)】我想找个女朋友 HRBUST - 1978]]></title>
    <url>%2F2017%2F11%2F26%2F4-wo-xiang-zhao-ge-nv-peng-you%2F</url>
    <content type="text"><![CDATA[我想找个女朋友 HRBUST - 1978 孤独的1注定了单身，但是1虽然不能找到自己的另外一半却可以找到自己的小伙伴。现在总共有n个数字聚会，问1可以找到多少个小伙伴？ Input 本题有多组测试数据，测试次数不超过100000。对于每组测试，输入一个正整数n （1 ≤n ≤ 100000）。 Output 对于每组数据输出答案，占一行。 Sample Input 913 Sample Output 16 Hint 对于第二组数据，1,2,3,4,5,6,7,8,9,10,11,12,13这些数字中共有1,10,11,12,13共6个1。 题意 略 题解12345678910111213141516171819#include&lt;stdio.h&gt;int main(void)&#123; int n,i; while(scanf("%d",&amp;n) != EOF)&#123; int cnt = 1; for(i = 2;i &lt;= n; i++)&#123; int b = i; while(b)&#123; int a = b%10; if(a == 1) cnt++; b /= 10; &#125; &#125; printf("%d\n",cnt); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(3)】快乐的跳跃者 UESTC - 508]]></title>
    <url>%2F2017%2F11%2F25%2F3-Kuaile-de-tiaoyueze%2F</url>
    <content type="text"><![CDATA[快乐的跳跃者 UESTC - 508 对于一个包含n(n&gt;0)个元素的整数序列，如果序列中相邻元素之差的绝对值取遍从1到n−1的所有整数，那么这个序列就叫做jolly jumper。例如：1 4 2 3 就是一个jolly jumper，因为相邻元素之差的绝对值分别为3、2、1。写一个程序来判断一个序列是不是jolly jumper。 Input 有T组测试数据。输入的第一行是数据组数T，其后每一行是一组测试数据。每行包含一个整数n(n≤300)，然后是n个整数，表示一个输入序列。 Output 对于输入的每一行，输出一行Jolly或者Not jolly来表示它是否为jolly jumper。 Sample Input 24 1 4 2 35 1 4 2 -1 6 Sample Output JollyNot jolly 题意 略 题解1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;int main(void)&#123; int i,t,n,cnt; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;n); int *a,*b; a = (int *)malloc(sizeof(int) * n); b = (int *)malloc(sizeof(int) * n - 1); for(i = 0;i &lt; n - 1; i++) b[i] = i + 1; for(i = 0;i &lt; n; i++) scanf("%d",&amp;a[i]); for(i = 0;i &lt; n - 1; i++) &#123; int x = abs(a[i] - a[i + 1]); for(cnt = 0;cnt &lt; n; cnt++) &#123; if(b[cnt] == x) &#123; b[cnt] = 0; break; &#125; &#125; &#125; int sum = 0; for(i = 0;i &lt; n - 1; i++) &#123; if(b[i] == 0) sum++; &#125; if(sum == n - 1) printf("Jolly\n"); else printf("Not jolly\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(2)】反恐训练营 HDU - 1243]]></title>
    <url>%2F2017%2F11%2F24%2F2-Fankongxunlianying%2F</url>
    <content type="text"><![CDATA[反恐训练营 HDU - 1243 当今国际反恐形势很严峻，特别是美国“9.11事件”以后，国际恐怖势力更是有恃无恐，制造了多起骇人听闻的恐怖事件。基于此，各国都十分担心恐怖势力会对本国社会造成的不稳定，于是纷纷在本国的军队、警察队伍中开展了反恐训练。作为反恐立场坚定的大国，中国也十分重视在人民解放军、武装警察部队、人民警察队伍中反恐训练，还专门成立了反恐特警队。 炜炜是反恐特警队的一名新队员，现在正在接受培训。这几天刚好是射击训练第二阶段——实弹应变训练的日子，此前的第一阶段里，炜炜经过努力，已经将自己训练成为一个百发百中的神抢手了！这次，他将背着国产最新型12.7mm重型狙击枪进行训练比赛。 这次训练比赛的规则是这样的： 1、每个队员从出发点开始，沿着一条唯一的笔直道路跑直到终点，途中不允许往回跑，否则将被取消比赛资格。2、出发前，每个队员的枪膛内都被装了顺序一样的、用小写英文字母标明类型的子弹序列，每位队员被告知这一序列的信息；同时，每位队员也被告知恐怖分子即将出现的序列和类型（同样用小写英文字母标明类型）。3、在跑动的过程中，若发现“恐怖分子”，特警队员可以选择用枪击毙他，来得到写在“恐怖分子”胸前的得分，但是前提是他使用的子弹类型必须和“恐怖分子”类型相同，否则，即使击毙了“恐怖分子”，也得不到分数；当然选择不击毙他也是可以的，这样他不会从那个“恐怖分子”身上得到分数。4、允许特警队员放空枪，这样可以消耗掉型号不对的子弹而不至于杀死“恐怖分子”（当然每个特警队员都不会愚蠢到不装消音装置就放空枪，以至于吓跑“恐怖分子”），等待枪口出现正确型号的子弹击毙他得分。 这里，我们假定：1、对于每个队员，途中出现恐怖分子的地点、时间、类型也是完全一样的。2、每颗子弹都是质量合格的，都可以发挥杀伤效力3、由于队员各个都是神枪手，一旦他选择了正确的子弹，向目标射击，目标100%被爆头4、每个队员的记忆力超强，能记住所有子弹序列信息和恐怖分子序列信息。5、每个队员体力足够好，能跑完全程，并做他想要做的6、“恐怖分子”是不动的，小范围内不存在多于一个的恐怖分子； 炜炜需要你的帮助，告诉他如何做，才能得到最高的分数。现在如果告诉你出发时枪膛内子弹的序号和型号、恐怖分子出现的序号和类型，你能告诉炜炜他最多能得到多少分数吗？ Input 输入数据的第一行有一个整数N表示子弹和恐怖分子的类型数。随后的一行是各种恐怖分子类型的一行字母，两个字母之间没有任何字符。接下来的一行是击毙上一行对应位置恐怖分子类型的得分数，每个分数之间恰有一个空格。第三第四行分别表示开始时枪膛内子弹的序列（左边的先打出）和恐怖分子出现的序列（左边的先出现），字母之间都没有任何字符。每个测试数据之间没有空格和空行。你的程序必须通过全部测试数据，才能被判为AC。 Output 对于每一个测试数据，输出炜炜最多能得到的分数。 Sample Input 3abc1 1 1abcccc3abc1 1 1cccaba Sample Output 10 题意 对于每一次训练，都有n种类型的子弹和n种类型的恐怖分子，当子弹类型和恐怖分子的类型一一对应的时候才能获得相应的分数。当然，也可以选择放空枪或者放走不同的恐怖分子。因此，我们要得到最多的分数，就要知道最多有多少相同类型的子弹和恐怖分子，并且需要是有序的；因此需要用到最长公共子序列(LCS) 题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;stdio.h&gt;#include&lt;string.h&gt;int dp[5000][5000];//作为选取最长公共子序列的表格int max(int x,int y)//选择最大的一项作为返回值&#123; if(x&gt;y) return x; else return y;&#125;int main(void)&#123; int l1,l2,n,i,j,x; int c[200];//记录分数 char k; char e[5000],t[5000],p[5000];//e用来记录恐怖分子类型，t记录恐怖分子类型序列,p记录子弹序列， while(scanf("%d\n",&amp;n) != EOF)&#123; gets(e); for(i = 0;i &lt; n; i++)&#123; scanf("%d",&amp;c[i]); &#125; getchar(); gets(p); gets(t); l1 = strlen(p); l2 = strlen(t); for(i = 0;i &lt;= l1; i++) dp[i][0] = 0; for(i = 0;i &lt;= l2; i++) dp[0][i] = 0; for(i = 1;i &lt;= l1; i++)&#123; for(j = 1;j &lt;= l2; j++)&#123; if(p[i - 1] == t[j - 1])&#123; for(x = 0;x &lt; n; x++)&#123; if(e[x] == t[j - 1])&#123; k = c[x]; break; &#125; &#125; dp[i][j] = dp[i - 1][j - 1] + k; &#125;else&#123; dp[i][j] = max(dp[i - 1][j],dp[i][j - 1]); &#125; &#125; &#125; printf("%d\n",dp[l1][l2]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【每日一题(1)】开门人和关门人 HDU - 1234 (05年浙大计算机研究生考试)]]></title>
    <url>%2F2017%2F11%2F23%2F1-open-closePersonHDU1234%2F</url>
    <content type="text"><![CDATA[开门人和关门人 HDU-1234 每天第一个到机房的人要把门打开，最后一个离开的人要把门关好。现有一堆杂乱的机房签到、签离记录，请根据记录找出当天开门和关门的人。 Input 测试输入的第一行给出记录的总天数N ( N &gt; 0 )。下面列出了N天的记录。每天的记录在第一行给出记录的条目数M (M &gt; 0 )，下面是M行，每行的格式为 证件号码 签到时间 签离时间 其中时间按“小时:分钟:秒钟”（各占2位）给出，证件号码是长度不超过15的字符串。 Output 对每一天的记录输出1行，即当天开门和关门人的证件号码，中间用1空格分隔。注意：在裁判的标准测试输入中，所有记录保证完整，每个人的签到时间在签离时间之前，且没有多人同时签到或者签离的情况。 Sample Input 31ME3021112225321 00:00:00 23:59:592EE301218 08:05:35 20:56:35MA301134 12:35:45 21:40:423CS301111 15:30:28 17:00:10SC3021234 08:00:00 11:25:25CS301133 21:45:00 21:58:40 Sample Output ME3021112225321 ME3021112225321EE301218 MA301134SC3021234 CS301133 题意 每天都会有人签到，问最早到和最晚走的人 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;struct node&#123; char id[16];//建立每个人签到记录的结构体 int h1,m1,s1; int h2,m2,s2;&#125;;int h1,m1,s1;int h2,m2,s2;char name1[16],name2[16];void swap_min(int i,struct node *a)&#123;//比较最早到的人 h1 = a[i].h1; m1 = a[i].m1; s1 = a[i].s1; strcpy(name1,a[i].id); //return;&#125;void swap_max(int i,struct node *a)&#123;//比较最晚走的人 h2 = a[i].h2; m2 = a[i].m2; s2 = a[i].s2; strcpy(name2,a[i].id); //return;&#125;void find_min(int i,struct node *a)&#123;//存放最早到的人 if(a[i].h1 &lt; h1)&#123; swap_min(i,a); &#125;else if(a[i].h1 == h1 &amp;&amp; a[i].m1 &lt; m1)&#123; swap_min(i,a); &#125;else if(a[i].h1 == h1 &amp;&amp; a[i].m1 == m1 &amp;&amp; a[i].s1 &lt; s1)&#123; swap_min(i,a); &#125; //return;&#125;void find_max(int i,struct node *a)&#123;//存放最晚走的人 if(a[i].h2 &gt; h2)&#123; swap_max(i,a); &#125;else if(a[i].h2 == h2 &amp;&amp; a[i].m2 &gt; m2)&#123; swap_max(i,a); &#125;else if(a[i].h2 == h2 &amp;&amp; a[i].m2 == m2 &amp;&amp; a[i].s2 &gt; s2)&#123; swap_max(i,a); &#125; //return;&#125;int main(void)&#123; int n,i,m; scanf("%d",&amp;m); while(m--)&#123; scanf("%d",&amp;n); node *a; a = (node *)malloc(sizeof(node) * n); //建立结构体数组 for(i = 0;i &lt; n; i++)&#123; //找出最早和最晚的人 scanf("%s %d:%d:%d %d:%d:%d",&amp;a[i].id,&amp;a[i].h1,&amp;a[i].m1,&amp;a[i].s1,&amp;a[i].h2,&amp;a[i].m2,&amp;a[i].s2); if(i == 0)&#123; swap_min(i,a); swap_max(i,a); &#125;else&#123; find_max(i,a); find_min(i,a); &#125; &#125; printf("%s %s\n",name1,name2); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F2017%2F11%2F20%2FHello-World%2F</url>
    <content type="text"><![CDATA[2017年11月20日： 花费了4个小时，基于 hexo + github 的博客终于搭建完成了，高中时候做过班级网站，不过是嵌套模版(域名已过期); 现在灵感再起，重新搭建一个属于自己的博客，用于记录学习以及生活；本人会认真学习，吸取教训，并将学习与实践相结合，令知识点深入生活，易于理解。但本人学识浅陋，若有不严谨以及错误之处，请您与本人联系；]]></content>
  </entry>
</search>
